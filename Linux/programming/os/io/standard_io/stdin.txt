我们使用C++的cin和cout进行标准输入输出。
首先，STDIN、STDOUT和我们之前无数次创建过的套接口没有区别，它们都是fd，因而虽然键盘和屏幕只有一个，但是STDIN、STDOUT是属于进程的，而不是属于操作系统的，这一点务必要清楚。
其次，套接口是有缓冲区的，那么STDIN、STDOUT也是有缓冲区的，可以把用户认为成一个线程，输入的本质是一个生产者-消费者模型。

我们着重探讨cin对象，这个对象是一个全局对象，它有很多有用的成员函数：
	operator>>：用于从输入流中提取数据并存储到变量中，相当于scanf。
	get()：用于读取并返回下一个字符，相当于getchar()或者getc。
	getline()：用于读取一行文本，并存储到字符串变量中，相当于gets或者fgets。
	ignore()：用于忽略指定数量的字符，这是一个重要函数，有助于提升输入处理的鲁棒性。
	peek()：用于查看输入流中的下一个字符，而不会将其从流中移除。
	tellg()：用于获取当前的输入流位置。
	seekg()：用于设置输入流位置到指定的位置。
	clear()，如果某次cin>>出错了，cin会设计一个标记表明输入缓冲区出错，之后输入缓冲区不能再使用，使用clear函数可以清除该标记。

cin>>的工作原理（\n及空白字符的作用）如下：
	1对用户：用户可以进行任意输入，甚至可以有心构造数据，这一点必须认识到，但是有一点用户不得不遵循，即：使用\n发送数据，具体地说，\n可以让shell继续。
	2对接收进程，>>接收数据的基本原理是：一个cin对象在>>时，如果【没有数据，一定注意是没有数据，如果有那么cin就直接读，理解这一点至关重要！！！】被操作系统通知就会一直阻塞等待，直到用户发送了数据，，cin>>会一个一个字节的读取数据，直到遇见\n（注意：\n并不读取），>>返回。
		cin在读取过程中可能会出现两种错误：
			①数据类型不匹配：
				a.数值和字符不匹配：比如cin>>num，num是一个int，但是用户却发送了abcd，此时cin>>在读到a时发现不匹配，便会放弃读取，以错误返回并给整个缓冲区设置错误标记，
					重点是：abcd还留在缓冲区中；下次读取时，因为还有数据在缓冲区中，cin>>不会阻塞，而是直接读取。
				b.数值溢出，比如cin>>num，num是一个int，我们知道int只有10位，如果用户发送了3333333333333333333333呢？不同于a.的情况，cin>>会读取完所有的数据，但是由于3333333333333333333333并不是int类型，因而报错。
					重点是：3333333333333333333333会被全部读走；下次读取时，缓冲区中没有因为错误造成的遗留数据。
				这里有一个编程上的细节：cin在出错返回后，按理说是要返回这个cin对象，一般而言要使用fail()成员函数判断是否出错，但是如果cin>>在分支或者循环结构里，C++会隐式将cin转成转成bool型，也就是成功为非0，出错为0。
				注意：b.的这种溢出并不会造成严重影响，因为这不是缓冲区溢出，而是数值溢出导致数据类型不匹配，它本质上还是数据类型不匹配，但是接下来这种可就严重了！
			②缓冲区溢出：比如cin>>s，s是一个3字节的数组，此时用户输入了hello，这是5个字节，那么会发生什么呢？答案是cin不会对hello产生任何怀疑，而数组也不会对越界做任何控制，整个程序不会报任何错误，这成了一次正常的cin操作，而这恰恰是最大的错误，因为这将会引发严重的安全漏洞。
		对接收进程来讲，\n确实是用来返回的，但是如果用户没有发任何实际的数据只发送了\n呢？此时，什么都不会发生，\n确实在缓冲区里，但是cin对\n的态度是“视而不见”，即选择忽略。
			对接收进程而言，这里有一条规则：cin只有在读到非空白（空格、Tab、回车）数据的之后见到空白字符（注意是所有的空白字符而不只是\n）才会返回，这之前空白字符是被忽略的，也就是说，在非空白数据之前，任何空白数据都将忽略不计，在非空白数据之后，见空白字符返回，此时空白字符将不会被读走，下一次cin>>将从该空白字符开始。
			根据上面这条规则，可以看出，三个空白字符并非一条心啊，只有\n可以发送数据，但是同样是空白字符的空格和Tab却没有此功效，但是三者一样的是对于接收进程而言，接收进程都读到它们时返回有可能会出现这种情况：cin>>num;，num是int，用户构造了这样一条数据：123 456，此时会发生什么呢？此时将会造成严重的运行时错误，cin>>碰到空格返回了，首先读走了123，然后在下次cin>>时由于输入缓冲区中还有数据，接着读走了234，然后就没数据了，此时等待用户发送数据。

事实上，>>一般是不用的，因为其弊病太多，一般使用getline，与>>不同的是：
	1用户也是只能提供\n让shell继续，getline和>>接受数据的原理也一样，但是对接收进程而言，只有\n才能让getline返回，空格和Tab都被视为一个普通字符。
	2这个函数将所有字节视为字符，因而不会存在数据类型不匹配的问题。
	3cin.getline可以避免缓冲区溢出，cin.getline函数的原型是：
		istream& getline (char* s, streamsize n );
		注意区分：istream& getline (istream&  is, string& str, char delim);  ，这两个getline函数名字完全一样，但是有两个重要区别：
			①该函数是std函数而非cin对象的成员函数。
			②cin对象的getline接收char*作为参数，而std::getline接收string对象作为参数。
	除了以上三点不同，cin.getline函数还有一些特性：
		①比如你设置n=3，那么cin.getline实际会读3个字节的数据？事实是它实际会读2个字节的数据，因为它视用户的输入为字符串，而用户在前端是没法输入\0的，因而它默认会给读到的数据加上\0，所以实际读取的数据必须要比用户给定的小一个字节，因而比如我们现在希望getline读取11个字节（设为length）的数据，我们应该设置n=length+1。
		②当发生用户输入大于length的情况时，比如length=11，n=12，此时用户按理说只能输入11个字节，但是由于用户的输入具有任意性，此时用户输入了12个字节，那么会发生什么？
			cin.getline会报错，但是数据还是会读到用户缓冲区里，并且由于输入缓冲区中还剩了一个字节的数据，getline不会等待，而是直接读取了这一个字节的数据。
			针对上面的问题，我们需要在报错后做两个处理：
				a.清楚错误标记并清空输入缓冲区直到\n。
				b.清空用户缓冲区；