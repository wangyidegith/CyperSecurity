Linux开发：内存管理（数据结构）       文件管理       进程管理       网络管理（socket）	IO
	内存管理：暂时不要理会底层的虚拟内存与物理内存的映射，只管虚拟内存（我们非常熟悉的进程模型，关于进程模型，首先要了解的就是操作系统的两层结构），事实上只要熟悉C/C++编程的数据方面，在实际开发中关于内存的知识储备已经够了

	文件管理：详见本目录《文件》

	进程线程（进程学习路线：进程概念（定义→本质→PCB）→多进程→进程间通信，线程学习路线：线程概念（定义→本质→TCB）→多线程→多线程同步）：
			进程概念：
				定义：程序在CPU和内存上运行起来就是进程
（这里插一条关于计算机硬件的知识：CPU+内存是计算机的核心系统，当然这里也包括了寄存器和缓存，寄存器离CPU更近，除此以外，剩下的都是外部设备，包括文件系统、输入输出设备、网络等，这些统一用一套系统API进行操作（Linux下一切皆文件），在以后的开发中，网络可能是我们最常用的外部设备）
				本质：最小的资源分配单位，进程与进程之间目前我还不知道共享什么，应该是完全独立的，包括文件描述符也不是共享的，但是我们可以使用一些IPC机制使得文件描述符共享。
				进程控制块（PCB）：一个程序开始运行的时候，OS会在内核中为该进程设置一个PCB，由PCB负责管理该进程的诸多事宜
					诸多事宜（十条）：
						进程标识符（PID）：唯一标识每个进程
						程序计数器（PC）：指向当前进程正在执行的指令的地址
						文件描述符表：记录进程已打开的文件和其属性
							注意：多个进程可以同时打开一个FD
						寄存器信息：保存 CPU 中的寄存器和其他相关寄存器的值。
						进程状态（诸多事宜里最重要的知识点）：记录进程的状态。
							进程有哪些状态？状态之间的关系是什么？——详看进程状态转换图
							为什么状态转换图是这样的？或者说为什么会存在就绪和等待（阻塞）这两种状态及相关关系？——并发
								并发涉及进程调度算法和中断机制
									现代操作系统的调度算法以时间片轮转（RR）为核心，配合优先级调度算法（PRI），MFQ便是一种结合了RR和PRI的调度算法
									中断分为硬中断（最经典的就是时钟中断）和软中断（又叫陷阱机制，最经典的就是IO操作）						
						进程优先级：确定进程在运行队列中的优先级。					
						环境和上下文信息：存储进程运行时的环境和上下文信息
						内存分配情况：记录进程已分配的内存及使用情况
						系统资源使用情况：记录进程所占用的各种系统资源（如 CPU 时间、I/O 设备、内存等）的使用情况
						指向父子进程的指针

			多进程和进程间通信（为什么？怎么做？——本质）：详见本目录《多进程》的《进程》			
			线程概念：
				定义：轻量级进程（light-weight process， LWP），LWP也是线程在Linux中的称谓
				本质：最小的CPU调度单位，或者说最小的并发单位，因而线程相比于进程，线程并不是完全独立的，而是在计算上独立，内存上除了栈和寄存器不共享以外都共享
				          线程的共享与不共享：
					共享：除了栈和寄存器以外的进程地址空间，线程从本质上来讲就是栈和寄存器的集合
					不共享：栈和寄存器，除此以外，线程还不共享如下信息：
						线程id
						调度优先级
					关于线程间信号的共享与不共享再议，这是一个相当乱的问题
				线程控制块（TCB），一般包括如下信息：
					任务的唯一标识符：线程 ID
					任务的当前状态，例如就绪、运行、阻塞等
					任务的优先级，用于确定任务的调度顺序
					任务的程序计数器（PC），指向当前任务正在执行的指令地址
					任务的寄存器值，包括通用寄存器、程序状态字（PSW）等寄存器的值
					任务的堆栈指针，指向任务的堆栈顶部
					任务的堆栈大小，表示任务的堆栈空间大小
					任务的内存映像，包括代码段、数据段、堆和栈等
					任务的文件描述符，用于访问任务的文件系统资源
					任务的 CPU 时间片信息，包括已经使用的 CPU 时间和剩余的 CPU 时间等
			多线程和多线程同步：详见本目录《多进程》的《多线程》。

		网络管理：详见本目录《socket》