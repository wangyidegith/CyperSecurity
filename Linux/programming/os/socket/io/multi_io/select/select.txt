一 机制
程序员准备一个长达1024的位图fd_set，
对其FD_ZERO，
将需要监听的套接字FD_SET入fd_set，
将其作为传入参数传入select函数【int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);】，
select函数会轮询位图以判断用户需要监听的套接字是否有事件，
如果没有一个有事件：在timeout设置为NULL的情况下继续轮询直到有事件（这是阻塞的情况，可以设置超时时间），
一次轮询后若有套接字有事件则返回：原来传入的fd_set现在作为传出参数传给用户，
注意：
fd_set作为一个数据结构既作为传入参数又作为传出参数，
在实际编程实现时就需要定义一个事件数据结构的数组（作为组织数据结构）来存储目前的客户端。







二 分析上述的select机制，可以看到select有这么几个缺陷
1 能监听的fd的数量有限，仅为1024，这不可能满足高并发需求。

2 需要自行设计全部客户端数据结构（其元素是单个客户端数据结构，这个本来就得程序员设计）。

3 监听集和事件集不分离。
