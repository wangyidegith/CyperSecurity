socket是一些资源和一些算法的句柄，尤其是缓冲区资源。

TCP UDP 的区别：
	连接：
		TCP面向连接：连接的概念：一对一（dst_ip+dst_port : src_ip+src_port），一旦三次握手完成，标识该连接的套接字只能从dst接收数据到src，也只能从src发送数据到dst。
		UDP无连接：没有所谓“对”的概念，只有（src_ip+src_port），一个UDP套接字可以从src向任意ip+port发包，也可以接收任意ip+port的包到src。
		二者在连接上的区别导致了：TCP在进行代理转发时不需要考虑NAT类型，而UDP需要考虑。
		首先NAT是一种网络层技术，按理说，位于应用层的程序员是不需要考虑网络层而只需要考虑传输层的，但是无奈的是，NAT这个网络层技术使用了传输层的端口号机制（端口映射），所以这导致在代理服务器（我们一般默认代理服务器是正向的，但是反向代理或者说打洞中是一定会考虑NAT类型的影响的）这种场景中需要应用层的程序员考虑NAT类型可能造成的影响。
		其次NAT有两种类型：
			Cone（对src_ip+src_port做映射，而不映射dst_ip+dst_port），Cone针对dst的回包有三种处理方式：Full Cone（不记录dst_ip+dst_port，对任意dst的回包来者不拒），Address-Restricted Cone（记录dst_ip，只接收来自dst_ip的回包），Port-Restricted Cone（记录dst_ip+dst_port，只接收来自这个dst_ip+dst_port的回包）。
			Symmetric（对src_ip+src_port+dst_ip+dst_port做映射），这种情况在处理dst的回包时和Port-Restricted Cone一样，但是它更加严格，它是最严格的NAT类型，对于Port-Restricted Cone而言，只要src_ip+src_port不变，那么，映射出来的public_ip+piblic_port是不变的，但是对于Symmetric而言，public_ip+public_port的变化是非常随意的。
		为什么TCP根本不需要考虑NAT类型的影响而UDP需要考虑？根据以上对于NAT类型的认识，src在NAT网络中向公网中的dst发包，对端回包时如果使用src发送时的dst，那么这对于任何NAT类型都是受用的，但是问题是，对端回包时如果使用了不同的dst，那么，Full Cone是可以回包成功的，Address-Restricted就不一定了，如果对端只变了dst_port而没有改变dst_ip那么可以回包成功，如果都变了就不行了，Port-Restrcted和Symmetric将不再接收这个对端的回包。所以————，TCP由于其是一对一的，对端根本不可能换dst，因而TCP根本无需考虑NAT类型的影响，但是对UDP，对端是可以随意换dst的。
		在实际开发中，公网中的UDP为了避免NAT的影响，需要以同一个套接字进行收发（意思是哪个套接字负责接收数据，那么在给发送端回数据时也必须使用该套接字，而不能更换该套接字的绑定）。
		但是，像上面的一般的UDP服务器或者UDP正向代理的开发场景中，我们可以通过编程手段避免NAT类型的影响，但是有一个场景很特殊，那就是P2P，P2P程序需要UDP打洞，这势必会导致dst被更换，所以udp打洞只适合于Full Cone。
		但是————，我确实看到了很多P2P程序实现了无差别的UDP打洞，甚至实现了TCP打洞，比如区块链，它们是怎么做的呢？？
	可靠
		TCP是可靠的，不存在丢包。
		UDP是不可靠的，存在丢包，如果分片后，某个包丢了，UDP将丢弃整个包。
	socket收发缓冲区
		每一个套接字都对应了一个收发缓冲区，其中接收和发送相互独立。
		结构（recv）
			TCP的socket缓冲区的逻辑结构是一个字节数组。假如来了1w个字节，我们应用层先读5000B，然后再去读剩下的，是可以读到的。所以————，基于TCP的代理服务器在实现上非常简单，根本不需要关注用户的数据有多长，随便你读多少再转发出去就行了，你甚至可以只读一个字节。
			UDP的socket缓冲区的逻辑结构是一个循环队列，假如来了1w个字节，我们应用层先读5000B，然后再去读剩下的，是读不到的。所以————，UDP应用层在处理未知长度的数据转发时非常难受，我们根本不知道用户要发多长数据，自然就不知道该开辟多大缓冲区，开辟大了浪费内存，开辟小了代理失责，所以，应该怎么办呢？？
			以上是从代理层面认识结构导致的TCP和UDP的区别，从应用层看，TCP的字节流结构导致了应用层需要解决粘包，而UDP不需要解决粘包。
		大小（send）
			1 传输层：TCP 65535 UDP 65507	不能调整
			2 socket：TCP r128KBs16KB UDP r208KBs208KB 可调整
			3 应用层：
				首先，作为一个应用层的程序员为什么需要考虑长度？因为MTU，其实不考虑也没关系，因为IP层会帮我们分片和重组，但是为了提升效率和降低丢包率，我们应该尽量避免让网络层去分片和重组。
				在接收时这无所谓，但是在发送时，TCP无需考虑发多大，因为TCP有一个MSS机制，在握手时，TCP会进行MTU发现或者使用默认值，根据MTU计算一个报文段的长度（1460B或536B），再交给IP层，也就是说TCP帮我们做了分片和重组，因而在使用TCP时，我们只需要确保自己发送的数据长度不超过socket的SNDBUF的长度就行了，如果超出，也可以用setsockopt去调。但是，对于UDP而言，并没有MSS，UDP直接把应用层给他的报文作为报文段去发送了，因而，为了避免分片，我们一般不让UDP应用层发送超过548B（Internet）或1472B（局域网）的数据，但是，在写代理时，我们可不知道用户会发送多大数据，因而此时代理就需要考虑是否进行分片和重组了，再次强调分片和重组不是一个必选项。
			4 原理：https://github.com/steveLauwh/TCP-IP/blob/master/UDP/UDP%20%E6%8A%A5%E6%96%87%E7%9A%84%E5%A4%A7%E5%B0%8F.md
