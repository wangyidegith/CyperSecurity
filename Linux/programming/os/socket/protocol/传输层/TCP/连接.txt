面向连接：
	概念：二元组唯一标识了一个进程，那么两个二元组即一个四元组就可以唯一标识网络上的一个进程对即连接，这就是连接的概念
	面向连接的本质：全双工的收发缓冲区，一个发送缓冲区一个接收缓冲区，二者相互独立，实现全双工通信，
				            在一台计算机上，收发缓冲区由一个端口号唯一标识，对于上层用户而言这个端口被封装进了一个套接字描述符，
				          【TCP网络编程的本质：对于一个基于TCP的应用程序的开发者而言，他必须认识到一个本质性问题：所谓的向一个套接字里写数据或者说从一个套接字里读数据本质上是在与TCP的收发缓冲区进行交互，基于这一点有两点需要认识到：①应用线程和TCP不是一个线程；②对于应用线程和TCP来讲，收发缓冲区是公共资源；③内核已经为我们提供了应用线程和TCP之间的同步关系。这里要注意：多个线程争用同一收发缓冲区是另一个同步问题。】
	连接管理：
		三次握手：
			主要目的：建立连接即通信双方建立起收发缓冲区等资源并协调相关参数。
			过程：
				客户端往往在调用connect时率先发起第一次握手（SYN=1），表明自己希望与客户端建立连接；
				服务器listen（listen是另一个线程）到SYN报文后建立相关资源，调用accept发起第二次握手（SYN=1，ACK=1）；
				然后客户端的connect接收到第二次握手，发起第三次握手连接建立完成，我是觉得这里connect会等待ACK返回再返回，这里可能不会真正读取数据，在第三次握手时客户端已经可以向服务器发送有效载荷。
			编程实现：connect→listen+accept，详见过程。
			三次握手存在的问题：黑客可以利用三次握手发起拒绝服务攻击，即向服务器发送大量第一次握手，但是却不接收第二次握手，但是服务器往往会误认为这是一个正常的连接，于是准备了相关资源，伴随着大量的第一次握手，服务器将不堪重负。
			【最重要的事情】：三次握手是传输层的事，但是它和应用层的IO可以在一个线程里同步进行，当然如果使用epoll，IO往往和三次握手是异步的，关于这一点，这似乎是句废话，但是对于没有深入接触过应用层以外的套接字编程的我来讲，这确实足够令人震撼，
				              也就是说，三次握手实际上可以在看作是基于SOCK_RAW的编程，而三次握手后面同步执行的IO是基于SOCK_STREAM的编程，他们位于不同层但却可以在同一个线程里。
		四次挥手：
			主要目的：释放连接即通信双方释放收发缓冲区等资源，值得注意的是，TCP的资源会在四次挥手的过程中被释放，但是要注意用户的线程资源是不会被释放的，因而这里用户需要自行释放线程资源。
			过程：一般情况下由客户端主动释放连接，服务器一般是不会主动关闭连接的；
				第一次：客户端shutdown(sockfd, SHUT_WR)关闭了自己的写缓冲区，发起第一次挥手（FIN=1）向对端表明自己希望断开连接；
				第二次：服务器的TCP收到FIN包后，应用线程read=0，我并不确定第二次挥手（ACK=1）是TCP收到FIN包后发送的还是read=0时read函数发送的，对于一个使用TCP的开发者而言，这个事情也并不重要，总之，第二次挥手是服务器向对端表明自己收到了对端的第一次挥手，但是此时服务器由于突然收到客户端释放连接的消息，可能还有数据未发送完毕，因而服务器此时并不可急于关闭连接，接下来服务器将进行最后一次数据发送；
				客户端收到ACK后，shutdown函数返回；
				第三次：当服务器发送完所有数据后（TCP的”发送完“指收到了对端的确认包，对于应用线程来讲，write返回就代表发完了，TCP会保证收到确认），调用close发起第三次挥手（FIN=1，ACK=1），以通知客户端我已发送完所有数据并关闭了连接，此时服务器应用层面的连接已经关闭，但是服务器的TCP并不能彻底断开连接，因为此时的服务器并不确定自己发送的FIN包能准确无误的送到对端手里，因而要等待对端对第三次挥手的确认包；
				第四次：客户端的TCP收到FIN包后，应用线程read=0，客户端知道了服务器已经发送完了所有数据并关闭了连接，此时客户端TCP向服务器发送第四次挥手，以告诉自己知道了你已发送完毕数据并关闭了连接，服务器收到该次挥手后，认为客户端已经关闭，然后放心地关闭连接，但是此时要注意一个问题，客户端TCP在发送完第四次挥手后真的就可以彻底关闭连接了吗？答案是并不可以。因为不管服务器能不能收到第四次挥手，客户端的TCP都不可能知道服务器是否收到了第四次挥手，如果收到了那客户端的担心就是多余的了，但是如果没收到呢？因而客户端并不能在第四次挥手后急于关闭连接，而是要等待一个超时时长（2MSL，大约为4分钟），在超时时长里，如果服务器没有收到第四次挥手那么将触发第三次挥手的重传。
			四次挥手存在的半关闭问题：
				半关闭：所谓半关闭指的是只关一个缓冲区，比如关了接收缓冲区或者发送缓冲区而保留另一个；
				四次挥手中的半关闭：？在四次挥手过程中，客户端在第一次挥手后关闭了发送缓冲区保留了接收缓冲区，那么，客户端的应用线程何时关闭接收缓冲区呢？根据四次握手的过程，显然shutdown(sockfd, SHUT_RD);这条语句不是任何一次握手，但是有一点是确定的在第三次握手后，该语句就可以执行了；
						  理论上服务器在收到第一次挥手后可以认为客户端已经不会再发送任何数据了，但是这可不一定啊，让我们首先分析一下客户端发起第一次挥手后的情况，shutdown(sockfd, SHUT_WR)向TCP通知关闭发送缓冲区，TCP在收到该通知后可不会去看看发送缓冲区的数据发完了没有而是直接将其关闭，也就是说，发送缓冲区的数据能不能发完应用线程是不知道的，可能发完也可能发不完，这里要注意，不管你有没有set(SO_LINGER)，shutdown函数都是再都到第二次挥手后才返回。
						  ？为了解决上面这个问题，Linux为我们提供了一种方法，允许在shutdown函数延时一段时间再关闭发送缓冲区，setsocketopt函数的SO_LINGER选项值可以设置shutdown的延时关闭时间，因而到现在我们可以猜测shutdown函数内部做了两件事：①发送FIN包；②关闭缓冲区，但是现在的问题是，有没有一种可能：第一次挥手时，服务器先收到了FIN包，此时read=0吗？那么服务器又收到了客户端发来的数据，那么read=多少？                                       		















