计算机网络的基本原理是：五层模型。关于五层模型，要理解：计算机网络的分层体系结构有两个概念：一是上下即服务，二是左右即协议。

服务是指五层模型的某一层利用了其下一层的功能，并为其上一层提供了功能，比如应用层的HTTP协议，利用了其下一层的TCP协议，为其上一层Web应用提供了通信机制；
协议是指通信标准，即同层对等实体要互相”认得“（按一套标准进行封包和拆包），这个标准包括数据包的数据结构和拆封算法。

关于协议和服务的概念，无论如何先记住一点：对于下一层，我是什么就给什么就拿什么，那么，我往上给的和从上面拿的自然就是我的上一层的分组。
另外需要意识到两点：
	①不是说基于IP协议写的协议就是属于传输层，同样是基于IP协议的ICMP和TCP属于不同层，ICMP和IP协议都属于网络层，ICMP相当于是网络层的一个应用程序；
	②ARP是链路层协议，但是使用了网络层才应该有的IP地址，NAT是网络层协议，但是使用了传输层才应该有的端口号，这个现象的原因有着复杂的历史背景。
	






从五层模型的角度看，”对于下一层，我是什么就给什么就拿什么“这个事情是多么清楚，但是在实际的网络编程中，这个事情似乎有点模糊，在这里我们要让这个事情不再模糊：——（）内的内容和三个比如
	一、在分析用户级网络编程的原理性问题（”对于下一层，我是什么就给什么就拿什么“）之前，我们要先弄清楚一个事情：用户级网络编程和内核级网络编程有何区别？
		用户级网络编程管不了协议栈的上层，这是因为协议栈在内核中，而我们使用用户级网络编程编写的是应用程序，这个程序不管是基于哪层socket写的，本质上都是运行在内核之上的应用进程，因而当我们写的应用进程接收到数据包时，这个数据包应用进程可自行处理，当我们使用该应用进程发送数据包时，这个数据包可由应用进程自定义。
		但是对于上面这段话，试想一下，如果我们希望可以截取上层下来的数据包或者下层过来的数据包，并对其进行修改或者过滤等操作后，再让协议栈将其交付给下层或者上层呢？显然用户级网络编程是做不到的，这就需要内核级网络编程了。
		总结上面两段话，可得，用户级网络编程和内核级网络编程的区别在于：前者是在使用协议栈，而后者是在修改协议栈。
	
	二、搞清楚了用户级和内核级的网络编程的差别，我们再来分析：用户级网络编程中，什么是”对于下一层，我是什么就给什么就拿什么“？而关于这个问题，我们需要学习socket函数（又名网络插口函数）：
		1. 函数原型：int socket(int domain, int type, int protocol);
		2. 返回值：socket函数为我们提供了操作网络中任一层的接口，所以socket函数也常被称为网络插口函数，其可以返回一个描述符作为我们与内核协议栈中的某个协议交互的句柄。
			 相关解释：
			 套接字描述符和普通的文件描述符表面上看没有区别，那么如何区分它们呢？——stat结构及fstat函数：虽然程序员从表面上区分不了fd，但是每一个fd的状态是不一样的。
			 而在stat结构内部，st_mode成员（下述结构中的第三个）可以用于区分不同类型的fd。
			 struct stat {
    				dev_t         st_dev;      /* 文件的设备 ID */
   				ino_t         st_ino;      /* inode 编号 */
    				mode_t        st_mode;     /* 文件类型S_IFMT（其中套接字类型为：S_IFSOCK）和访问权限 */
    				nlink_t       st_nlink;    /* 链接数 */
    				uid_t         st_uid;      /* 文件的用户 ID */
    				gid_t         st_gid;      /* 文件的组 ID */
    				dev_t         st_rdev;     /* 设备的 ID */
    				off_t         st_size;     /* 文件的大小（字节数） */
    				blksize_t     st_blksize;  /* 文件系统 I/O 缓冲区的大小 */
   				blkcnt_t      st_blocks;   /* 文件系统中分配的块数 */
    				struct timespec st_atim;   /* 文件最后一次访问的时间 */
    				struct timespec st_mtim;   /* 文件的最后一次修改时间 */
    				struct timespec st_ctim;   /* 文件的最后一次状态改变时间 */
			 };
			套接字描述符判定函数：
int isSocketType(int fd) {
	struct stat st;
	if (fstat(fd, &st)) {
		perror("fstat failed");
		return -1;
	}
	if ((st.st_mode & S_IFMT) == S_IFSOCK) {
		return 0;
	} else {
		return 1;
	}
}
		3. 参数
			第一个参数domain：告诉内核用户希望使用的网络协议栈或者说协议族，我想这个参数的设置是socket函数的设计者考虑到了会有多种协议栈的情况，在历史上确实有10种协议栈，但是经过计算机网络的发展，很多都被淘汰了，在Linux开发中也就5种协议栈(PF_XXXX或者AF_XXXX，这两个值没有明显区别)：
				AF_UNIX(AF_LOCAL)：用于进程间通信	                    AF_INET：TCP/IP协议栈的v4版本，也是现在最常用的版本	                    AF_INET6：TCP/IP协议栈的v6版本，未来的版本	             AF_NETLINK：与内核相关	          AF_PACKET：底层（数据链路层或者说驱动层）协议族
				在上述选项值中，除了用于本地通信的AF_UNIX(AF_LOCAL)、与内核相关的AF_NETLINK、未来版本AF_INET6以外，剩下的两个AF_INET和AF_PACKET就是我们在用户级网络编程中常用的协议栈了，其中AF_INET就是我们耳熟能详的TCP/IP协议栈了，TCP/IP协议栈是POSIX的标准，运行在Linux系统上。
			第二个参数type：在第一个参数的基础上即在选定协议族的基础上，告诉内核用户希望使用的协议类型，
				TCP/IP协议栈有5种协议类型：SOCK_STREAM	   SOCK_DGRAM	   SOCK_RDM	SOCK_SEQPACKET	       SOCK_RAW	其中，前四个是标准套接字，它们都使用了TCP、UDP、SCTP，SOCK_RAW是原始套接字。
				AF_PACKET有一种：SOCK_PACKET。
			第三个参数protocol：
				注意：该值会和收发的数据包中的协议号做比对，须是同一协议号才能收发成功，作为在网络上传输的数据包，其协议号字段必是网络字节序，因而需要对该值进行字节序转换。
				          关于这个参数的详解请详见《Linux网络编程》的8.5《协议名称处理函数》：protoent结构负责记录协议信息，其中有三个成员，分别是协议名、别名列表、协议值，其中第三个成员协议值与protocol参数相呼应，程序员可以直接观察234页的对应表，找到需要使用协议的协议值，并将其赋给protocol，但是为了程序的兼容性，建议使用231页的5个协议族处理函数，尤其是getprotobyname，程序员可以输入协议名称，该函数可返回一个包含了协议值的protoent。
				SOCK_STREAM：IPPROTO_TCP（默认为0）	6
				SOCK_DGRAM：IPPROTO_UDP（默认为0）	17
				SOCK_SEQPACKET：IPPROTO_SCTP（默认为0）	132
				SOCK_RDM：
					IPPROTO_UDP	6
					IPPROTO_SCTP	17
				SOCK_RAW：（协议号的取值范围是0~255，因而不需要进行字节序转换）
					IPPROTO_RAW	255
					IPPROTO_IP	0
					IPPROTO_TCP	6
					IPPROTO_UDP	17
					IPPROTO_ICMP	1
				SOCK_PACKET：
					ETH_P_ALL：接收所有协议类型的数据包
					ETH_P_IP：IPv4协议类型       ETH_P_IPV6：IPv6协议类型
					ETH_P_ARP：ARP协议类型	ETH_P_RARP：RARP协议类型              
					ETH_P_LOOP：本地环回协议类型
					ETH_P_PAE：802.1X身份验证协议类型
					ETH_P_PPP_DISC：PPPoE发现协议类型	ETH_P_PPP_SES：PPPoE会话协议类型
					ETH_P_TEB：桥接协议类型
					ETH_P_8021Q：VLAN协议类型
					ETH_P_8021AD：QinQ协议类型
					ETH_P_MPLS_UC：MPLS单播协议类型	ETH_P_MPLS_MC：MPLS组播协议类型
					ETH_P_IPX：IPX协议类型	ETH_P_APPLETALK：AppleTalk协议类型
	三、”对于下一层，我是什么就给什么就拿什么“到底是什么意思？
		（一）在回答这个问题之前，我们首先需要理解socket编程的本质（三级缓冲区结构）：
			首先我们先粗略地理解一下网络编程（三级结构），当我们使用socket函数创建了一个socket的时候，我们知道我们这个进程可以通过这个socket和某个协议进程（以下谈到的协议或者层都是指该协议的进程，事实上我们应该理解，IP协议进程只有一个，准确的说是：一张网卡（包括驱动即数据链路层进程） == 一个IP地址 == 一个IP协议进程，这是因为没有必要有很多IP协议进程啊）交互数据，这显然是一个三级结构：应用进程---socket---基于的协议。
			具体分析，我们会发现，socket的本质是：一个socket == 一个收发缓冲区，关于这个本质有三点需要解释：
				①首先，作为程序员要明白：你read(socketfd, buf, length);或者write(socketfd, buf, length);时，你read的数据是从哪来的？write的数据又到了哪去？你不要说是从下层协议来的到了上层协议那去那是废话，具体而言，read的数据是从socket中的接收缓冲区复制到buf的，write的数据是从buf复制到socket中的发送缓冲区去的。
				②其次，作为程序员要明白：【socket == 收发缓冲区】另外，关于收发缓冲区，需要说明两件事：
					a. epoll监听的也正是socket的收发缓冲区。
					b. 除了连接socket，剩下的socket（UDPsocket、TCP监听socket、所有的原始socket等）都是无连接的，连接socket的收发缓冲区是面向字节的，无连接socket的收发缓冲区是面向分组的，或者说，连接socket的收发缓冲区是字节数组，无连接socket的收发缓冲区是分组循环队列。（理解这一点对于理解TCP网络编程非常重要，基于无连接的socket编程时，发包时必须考虑数据包的构造和大小，不能超过MTU，否则会发送失败，而收包时一次读只能收到一个包，无需考虑粘包问题（这是我之前的错误认识，事实上无连接也会遇到粘包问题，因为你读的时候是在按照字节读啊），而TCP标准socket与其他socket最大的不同之处在于：恰恰相反的是，在发包时无需考虑报文段的划分，若超过了MSS，传输层会帮忙划分，但是应用层接收数据时需要解决字节级的粘包问题）
				③最后，作为程序员要明白：socket和基于的协议进程进行交互，那么和协议进程的什么进行交互呢？那自然也是协议进程的收发缓冲区咯。因而，【协议号 == 收发缓冲区】。
		（二）其次，在以上研究的基础上，进一步研究会发现一个更深层次的问题（本质的本质：多路复用分解）：从本质上来看，所有type（socket的第二个参数）的socket都符合三级缓冲区结构，但是不同sockettype（socket的第二个参数）的收发缓冲区的标识是不一样的。
			①标准socket由IP地址和端口号标识：
				对于UDP和TCP的监听socket来讲：（对于无连接的协议而言，它实际上只关乎本地，此时IP地址是没有意义的，就是说在接收的时候数据包已经到达IP层了，在发送的时候，这个数据包在IP层的上层，在上层哪不重要，总之不管发送还是接收，这个数据包已经在本地了，实际上此时IP地址已经丧失了它的意义，因而下面的表述如果去掉IP地址，只用端口号也是可以的）
					【IP地址+端口号 == 标准socket】
					注意：而往往一个服务器进程只创建一个监听套接字、一个基于UDP的进程一般也只创建一个socket，所以我们也可以说一个端口号标识了一个进程。
					          对于监听socket来讲，它只有接收缓冲区，也就是listen函数创建的监听队列。
				对于TCP的连接socket来讲：（面向连接的连接socket关乎整条连接，此时IP地址是有意义的）
					【本地IP地址+本地端口号+远端IP地址+远端端口号 == 连接socket】
			②现在终于到了整个原始socket编程中最核心的一个问题了：原始socket由什么标识呢？（除了TCP的连接socket是面向连接的，其他的协议或者说socket都是无连接的）
				回忆标准字的标识：
					标准socket由基于协议即传输层协议的端口号和网卡的IP地址进行标识，实际上协议号在这个过程中也起到了标识的作用，但是这个作用是默认的，根本没必要说，但是，值得注意的是，标准socket的标识是唯一性的标识，这也是我们认为的标识这个概念的意义，只有唯一标识才叫标识。
				什么标识了原始socket呢？
					事实上协议号确实一定程度的标识了原始socket，但是为什么说一定程度呢？因为这种标识并不是唯一性的标识，具体而言：【协议号 == N个原始socket】，你只要是使用socket(AF_INET, SOCK_RAW, IPPROTO_RAW);创建的socket，不管你创建了多少个socket3、4、5、6、7......，也不管这些socket在不在同一个进程里，这些socket发数据包时都往一个协议号缓冲区中发包，而收包时，不管是哪个socket也都从一个协议号缓冲区收包，换言之，一个协议号为IPPROTO_RAW的IP包，所有使用了IPPROTO_RAW的socket都可以收到。
				原始字原始在了哪？
					使用了同一个协议号（socket函数的第三个参数）的原始socket们通过收的包是无法区分的，这也是为什么一个标准的应用程序需要传输层的端口号机制了。
				需要注意的一点是：
					在发包时，我们要在两个地方填写协议号，一个是socket的第三个参数，一个是IP头部，这两个地方填写的协议号必须一致，不一致是发不出去的，注意是真发不出去而不是收到了然后给扔了。
		总结本质和本质的本质两个问题，可得：
			①一些对应关系：
				端口号：UDPsocket == 1：1
				端口号：TCP监听socket == 1：1
				四元组：TCP连接socket == 1：1
				协议号：原始socket == 1：N
			②某个协议在收发数据包时会发生什么？
				基于的协议进程会将应用层定义的粘合剂信息与数据包中的粘合剂进行比对，在发送时，如果比对一致则将其发送，不一致将包丢弃且不会给socket任何反馈信息，在接收时，如果比对一致则将其发送，不一致将包丢弃。
		标准套接字：（基于传输层协议，操作应用层，应用层完全由用户自定义）
			基于标准套接字的用户级网络编程是对”对于下一层，我是什么就给什么就拿什么“的最标准的实现，具体到socket函数，你是在基于第三个参数而不是在操作它代表的协议。
				比如socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);下一层是TCP协议，我是应用层，那么我在发包时给TCP协议应用报文，收包时从TCP协议那拿应用报文。
		原始套接字：（基于IP协议，操作应用层，应用层包括三类：①IPPROTO_RAW，相当于原始socket里的标准socket了，但是不同的是标准socket可不能操作传输层协议的头部；②ICMP、TCP、UDP等协议的自定义，这些协议对于IP来讲都是应用层协议，没有区别，但是ICMP工作在网络层，TCP、UDP工作在传输层；③用户自定义协议，说白了就是换一个协议号的IPPROTO_RAW）
			原始套接字和标准套接字的差别（理解差别对于理解整个套接字编程及原始socket编程都是最重要的事情）：
				①原始套接字的编程并不是对”对于下一层，是什么就给什么就拿什么“的标准实现，这是因为原始套接字编程不是在基于协议而是在操作协议，具体到socket函数，标准套接字编程是基于第三个参数，而原始套接字是基于第二个参数的一个统一协议——IP协议。
					比如socket(AF_INET, SOCK_RAW, IPPROTO_TCP);下一层是IP协议，我是TCP，那么我在发包时给IP协议TCP报文段，收包时从IP协议那拿TCP报文段。
					这个差别是表象，下面所言的是本质，也即从本质和本质的本质来看他们之间的差别。
				②另外，从本质来看：原始socket和标准socket都是三级缓冲区结构，但是不同的是，原始socket的缓冲区直接与协议号缓冲区打交道，但是标准socket的缓冲区透过传输层协议与协议号缓冲区交互；
				              从本质的本质来看，标准socket基于传输层协议（第三个参数），传输层与应用层之间的粘合剂是端口号或者四元组，而原始socket基于IP协议（第二个参数）操作TCP/IP协议栈中的各个协议（第三个参数），IP层和应用层的之间的粘合剂是协议号，注意，也就是socket的第三个参数。				
			关于原始socket编程，我现在还不是很确定两件事情：
				①IPPROTO_RAW和IPPROTO_IP的区别，我感觉二者的区别我只知道使用IPPROTO_RAW可以基于IP协议为所欲为；
				②《Linux网络编程》上对于IPPROTO_TCP和IPPROTO_UDP在接收数据时的解释。
			另外，这里还有一个IP头部的问题，IPPROTO_RAW默认收发的都是有头的IP包，IPPROTO_ICMP、IPPROTO_TCP、IPPROTO_UDP默认接收的是有头的IP包，发送的是无头的IP包，可以使用setsocketopt函数修改收发时的有头无头属性。
		链路套接字：（基于网卡驱动，操作应用层）
			比如socket(AF_PACKET, SOCK_PACKET, htons(ETH_P_IP));下一层是网卡驱动程序，我是IP，那么我在发包时给驱动帧，收包时从驱动那拿帧。
		关于链路socket与其他socket的差别我们将在接下来对三种socket的汇总中阐述它：
			我们可以看出，原始口和标准口用的是一个协议栈即TCP/IP协议栈（AF_INET），原始口和标准口的差别总结起来就是一句话：原始口在操作AF_INET而标准口在基于AF_INET；
			而链路口则使用另一个协议栈（AF_PACKET），那么，AF_PACKET应该也可以存在两种socket，一种负责操作一种负责基于，显然TCP、UDP不就是基于链路协议栈的IP协议开发出来的吗？但是链路协议栈并没有为用户提供基于socket，因为原始socket就是该功能，因而原始口和链路口的差别总结起来也是一句话：链路口在操作AF_PACKET而原始口在基于AF_PACKET；
			综上可得：原始口在操作AF_INET == 原始口在基于AF_PACKET
			（接链路套接字）
			明白了上面的差别，那么链路socket针对AF_PACKET类比原始socket针对AF_INET：
				①从本质来看，链路socket编程当然也满足三级缓冲区结构，原始口直接与IP协议的某个协议缓冲区交互，链路口直接与网卡驱动进程的某个协议缓冲区交互。
				②从本质的本质来看，协议号：原始口 == 1：N，类型号：链路口 == 1：N
			接下来我们将开始链路socket的具体内容的学习：
				①ifreq结构，该结构用于存储网卡信息，我们一般创建一个ifreq结构， 使用ioctl函数操作
struct ifreq {
    char ifr_name[IFNAMSIZ]; /* 接口名称 */
    union {
        struct sockaddr ifr_addr; /* 接口地址 */
        struct sockaddr ifr_dstaddr; /* 目标地址 */
        struct sockaddr ifr_broadaddr; /* 广播地址 */
        struct sockaddr ifr_netmask; /* 掩码地址 */
        struct sockaddr ifr_hwaddr; /* 硬件地址 */
        short ifr_flags; 
	/* 
	接口标志 【重要成员】：和epoll_event的第一个成员一个道理，采用如下流程设置该值：
		①获得标志位；
		②目标标志位 = 取出的标志位 | 要设置的标志位；
		③设置目标标志位；
	*/
        int ifr_ifindex; /* 接口索引 */
        int ifr_metric; /* 路由度量值 */
        int ifr_mtu; /* 最大传输单元 */
        struct ifmap ifr_map; /* 内存映射信息，该结构详见《Linux网络编程》的363页，该结构与驱动开发有关*/
        char ifr_slave[IFNAMSIZ]; /* 从接口名称 */
        char ifr_newname[IFNAMSIZ]; /* 新接口名称 */
        struct if_settings ifru_settings; /* 设备协议配置，不懂这个 */
        char *ifr_data; /* 接口数据，用户自行定义，一般用来传递标志 */
    } ifr_ifru;
};
				②以太网帧结构及各个头部的长度汇总：之所以要研究这个，是因为拿到的帧是最大的数据了，往往会根据头部取帧内的各部分数据。
					a. 以太网帧结构：目标MAC（6）	源MAC（6）	类型号（2）	              数据载荷（46-1500）	      CRC（4）
						CRC有硬件计算由驱动负责填写和剥离，用户无需管这个字段。
						类型号是以太网的粘合剂，如同IP协议的协议号和传输层的端口号一样，下面是几种常见的类型号：
							ETH_P_IP：0X0800
							ETH_P_IPV6：0X86DD
							ETH_P_ARP：0X0806
							ETH_P_8021Q：0X8100
						除了上面介绍的两个字段，下面将着重分析以太帧的长度问题：
							在<netinet/if_ether.h>中定义了如下常见宏：
							#define   ETH_ALEN   6	// MAC地址的长度
							#define   ETH_DATA_LEN   1500	// 以太帧有效载荷的最大长度
							#define   ETH_HLEN   14	// 以太帧的头部长度
							#define   ETH_ZLEN   60	// 不含CRC的以太帧最小长度							
							#define   ETH_FRAME_LEN   1514	// 不含CRC的以太帧最大长度
					b.IP头部长度：20	TCP头部长度：20	UDP头部长度：8







总结以上两个大问题，我们可以得出以下结论：
驱动基于硬件，以驱动为基点构成数据链路层协议族，IP协议也是其中一个；
IP基于驱动，以IP为基点构成网络层和传输层协议族即TCP/IP协议族；
应用可以基于传输层协议（标准口），可以基于IP协议（原始口）和驱动（链路口）。			