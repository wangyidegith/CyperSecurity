当我们创建一个线程的时候，相当于创建了一个函数，但是这个函数不受进程的控制，而是和进程“平起平坐”，都作为CPU的调度单位，因而为了方便程序员在主进程中更好地控制线程，
<pthread.h>库为我们提供了一些和线程结束相关的API；
另外，还有一点需要格外注意：一个进程一旦运行结束（主函数return或者exit），那么关于该进程的所有资源（资源有两种：计算资源和存储资源，实际上我们一般说的资源是存储资源）都没了，而线程可不这样：
一个线程本质上是栈和寄存器的集合，一旦线程运行结束，那么栈和寄存器肯定没了，但是问题是线程内部可以随意使用进程的各种资源啊，比如全局区、堆区、文件描述符，也就是说，一个线程malloc了一片堆区
空间，线程结束时如果这片空间没有被程序员free，那么进程是不会去检查这个线程还有哪些内存没有释放的，这样这片内存就成了一片泄露内存，白白占用着堆区存储资源。