条件变量本身存在的问题：
	①条件变量就是两个事情，一等待wait二唤醒signal或者broadcast；
		wait：该函数内部发生了三件事，一释放锁，二等待被唤醒，三加锁；
		如果等待条件变量的只有一个线程，那么signal和broadcast没有区别，但是如果有多个线程都等待在一个条件变量上，二者是不一样的：
			signal：唤醒某个线程，具体是哪个取决于线程在条件变量等待队列上的顺序，此时该线程与signal线程抢锁，
			            但是，【注意重点来了！】——也可能会出现该线程与其他线程抢锁的情况，如果该线程没有抢过signal线程，signal线程又唤醒了一个线程，此时新唤醒的线程与该线程构成竞争关系，因而在生产者-消费者模型中，我们是不可以使用if判断条件而必须使用while判断条件的，因为一个被唤醒的线程有可能因为没有抢到锁而拿不到fd，这样它虽然被唤醒了，但是当它拿到锁的时候，它面对的仍然是一个空队列；
			broadcast：唤醒所有线程，此时被唤醒的所有线程之间抢锁，它们同时也与broadcast线程抢锁；
	②等待的条件往往是全局数据，因而条件变量与互斥锁是分不开的；
		【注意重点来了！】——关于互斥锁的使用，有一条根本原则，那就是锁内的操作应该尽量简化，比如在生产者-消费者模型中，当读工人出队一个fd时，应该先释放锁，再进行读取操作；
		让我们仔细思考一下这个问题：
			试想一下如果在锁内read会发生什么？此时会有一个好事和一个坏事：
				好事是我们无需担心多个读工人读取同一个fd了，因为该读工人在读取该fd的时候，其它的读工人包括epoll主线程根本就拿不到全局队列，更不要说正好能拿到该fd了；
				坏事是这样做严重拖慢了程序的效率，其他线程需要等待这个拿到锁的线程读完数据才能抢锁，读操作本身就是一个费时操作啊；
			那么如果在释放锁之后read呢？此时也会有一个好事和一个坏事：
				好事是程序的效率大大提高；
				坏事是可能会出现多个线程同时读取一个fd的情况。
		显然根据我们在上一个【注意重点来了！】中说的，我们理应使用第二种，也就是在释放锁之后read，事实是程序的效率永远都是第一位的，因为服务器是要为客户提供服务用的，因而效率是第一的，至于说”可能会出现多个线程同时读取一个fd的情况“理当由服务器自身解决，而不应该归咎于客户端，关于该问题的解决，我们在《epoll的事件类型》中会详细解释，“单次事件”。