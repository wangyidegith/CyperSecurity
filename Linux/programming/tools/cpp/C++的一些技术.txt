new delete
	new相当于malloc，delete相当于free



std
	我觉得这个非常好，让程序阅读者更容易分得清自定义对象名和C++标准对象名



智能指针和引用
	这种指针的意义在于遵守“开始即获取，结束即释放”的原则，可帮助程序员避免因失误个人失误而造成的内存泄漏和野指针问题，新标准提供了两种指针：
		①unique指针：这种指针只能在初始化时指定对象，后续该对象不能被任何其他指针指向也就是说unique指针不能被复制，只能使用移动语义改变unique指针的所有者。
		②shared指针，有点类似于硬链接，引用机制是软链接。



模板<>
	C++除了C语言部分以外，还有另外一部分C语言不具备的东西——面向对象，其中多态部分，C++提供了一种非常好用的机制——模板，这种机制让程序员可以将数据结构和算法通用化。
	模板的本质在于数据类型参数化，数据类型参数化是一种重要的多态机制，而模板做的更绝，它直接不指定任何数据类型，完全由用户在<>里指定。
	著名的STL就是一组C++为程序员提供的模板库，里面的模板类又叫容器类，据此，C++还提高了70多种与STL容器相关的通用的常见的算法，这对开发帮助非常大。



两个前后问题：什么是前后问题？
传参问题：C++的函数的参数使用&即引用进行修饰，此时传过来一根指针给到了这个被&修饰的参数，那么这个参数是指针的别名还是指针所指向的内存空间的别名？
	该问题在epoll_queue_RPE.enqueue((type*)events[i].data.ptr);这里体现的淋漓尽致！
	所以是什么？——后者




字符串是最常见的数据类型。
在C语言中，
	1字符串是最精华的一部分知识，它完美地展现了C语言与内存模型的直接交互和指针的应用；
	2C语言有三种方式可以创建字符串，所创建出来的字符串在内存模型中的位置（分别对应常、栈、堆，这个真的太完美了！）以及定义方式、操作方式、sizeof都有区分，详情请看https://blog.csdn.net/qq_55770813/article/details/128217208
C语言为我们提供了很多操作字符串的方法，C++将很多方法封装到了string类中，方便了程序的使用，但是和C语言的字符串创建方式不同且不同的情况不一样，C++的string类不管如何创建，本质上都发生了如下过程：
	1比如std::string str = "Hello";，字符串"Hello"首先存储在程序的常量数据区，然后std::string类会在堆区动态分配内存来存储这个字符串，并将其拷贝到堆区中，str在栈区中。
		看见了没有？C++创建的字符串在常量区有备份，在堆区被操作，但是指向它的指针却在栈区，哈哈哈！
	2string有一个与C语言字符串不同的非常重要的特点，也是它的优势所在，即它指向的堆区内存的大小可以依据用户实际输入的数据长度动态改变，比如它原来指向的的堆区内存的大小是20B，结果实际字符串的长度是23B，那么，该堆区大小被string对象自动修改为了23B。	