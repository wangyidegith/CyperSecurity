零 可用来修饰类型（广义，但主要是存储）。







一 基本类型修饰符（为了统一说修饰符，把基本类型修饰符也放到存储文档里）
1 signed：表示变量可以存储正数、负数和零。默认情况下，整数类型为signed。

2 unsigned：表示变量只能存储非负整数（零和正数）。

3 short：表示短整型，占用存储空间较小，通常为16位。

4 long：表示长整型，占用存储空间较大，通常为32位或64位。







二 存储类型修饰符（所有数据类型其实在这区分起来就是对象和函数）
（一）修饰除函数以外的所有数据类型
1 auto：默认存储类型，局部变量默认为auto。

2 register：建议编译器将变量存储在寄存器中以提高访问速度。

3 volatile：作用一：告诉编译器变量的值可能在程序控制流之外被改变，因此需要每次从内存中读取值；作用二：常用于多线程环境，在多线程环境中，如果一个公共变量被volatile修饰，那么该值被某线程修改后，该值的变化会优先被告知给其他线程。



（二）修饰各种数据类型包括函数
1 extern：
理解了.h和.c的编译问题，就能理解它，extren不是在实例化（定义）的时候起作用而是声明在其他文件中已经定义过的对象和函数。
另外，函数本来就是extern的！

2 static：
（1）C语言：无非就是两类（函数内和函数外，注意结构体成员是不能用static修饰的）：
a 修饰函数内的变量也就是著名的静态局部变量，
b 修饰函数外，用来声明某变量或函数只在该文件可见，换言之，其他文件不能extern被static修饰的全局变量或函数（函数本来就是全局的），也不能在.h文件中对static函数做原型声明，这适用于那些仅在某文件内被调用的下级函数（我们称暴露在.h中的函数为一级函数），也有助于解决命名冲突，比如main.c引入了两个.h（f1.h和f2.h，分别是f1.c和f2.c的头文件），那么f1.c和f2.c中的下级函数就可以重名啊。
（2）cpp：除了上面的两类，还有两类（类的成员变量和成员函数，注意类本身是不能用static修饰的）：
a 修饰类的成员变量，表示该变量被所有实例共享，使用::访问（其实类和实例都能访问static成员变量，但是最好使用::访问以增强代码可读性）。
b 修饰类的成员函数，表示该函数只能操作static成员变量（其实根本原因是：static函数属于类所有，雷灾调用该函数时根本没有this指针），和static成员数据一样，使用::访问（其实类和实例都能访问static成员变量，但是最好使用::访问以增强代码可读性）。

3 const：
（1）对象：修饰对象表示某对象的值不能被修改。
a 修饰非指针数据。
b 修饰指针（常量指针（const在*后面）和指向常量的指针（const在*前面），其中指向常量的指针尤其常用）
指向常量的指针的用途：
（a）可以修饰函数的返回值，以不让外部修改返回的内存。
（b）可以修饰函数的指针类型参数，向用户表明本函数不修改用户传入的内存（指针类型的参数无非就是两种：一种传入后不做任何修改（这其实和赋值这种传入参数一样了）另一种传入之后函数会修改该片内存（这就是大名鼎鼎的传出参数啊），将传入后不做任何修改的指针参数修饰为const是一个好的编程习惯，让程序员和用户都可以轻松分辨参数表里哪些指针指向的内存会被修改哪些不会）。
（2）函数：
a C语言不能修饰函数只能修饰函数返回值。
b cpp可以修饰成员函数表示该成员函数不修改类的成员变量（注意：const必须放在函数名的后面而不能放在前面，放在前面是用来修饰函数返回值的）。
