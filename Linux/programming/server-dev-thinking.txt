0 服务器开发涉及的首要问题是数据量的大小问题（服务器开发老是说“多线程高并发”，其实就是“大数据量大用户量”，用户量是由负载均衡负责的而非线程的多少）
一般认为低于10MB是小数据量，10MB-100MB是中等数据量，大于100MB是大数据量，另外还得看处理逻辑是否复杂等因素。

大数据量多线程，小数据量使用单线程。







# 回忆一下epoll的三种触发模式的表面区别
lt只要有数据就触发。

et是有新数据才触发。

oneshot是只触发一次（相当于你在lt或et触发后把fd从红黑树上删了）







1 其次单线程用什么触发模式？多线程又用什么触发模式呢？（这是epoll三种触发模式真正的区别，所以以后面试被问到这个问题的时候别再不会说了）
单线程使用lt还是et没有区别，使用oneshot也是可以的。

多线程不能使用lt，
哪怕就是“epoll监听主线程 + 任务队列 + 处理线程”这种简单的多线程场景也不行，
因为一个包过来，epoll监听主线程会触发很多回，任务队列里面充斥了一个包的句柄，可处理线程调用的io函数会把这个包一次性读完，也就是说该包的第一次触发之后的触发都是无效的，去解决这些无效出发是没有意义的，
线程池那就更不行了。
多线程只能使用et或者oneshot，







# 回忆一下read函数的返回值，无非就是几种情况：
成功返回字节数：问题在于要读10B，只给了5B，那就只能读够5B，这种情况是亲眼所见情况1，那么如果要读10B，但来了20B呢？这不是read的问题而是触发的问题，详见下面。
对端关闭返回0：epoll是会将该事件作为读事件触发的。
失败返回-1和错误码，其中又分为三种情况（error、EINTR、EAGAIN（EWOULDBLOCK））：出错了你返回就行了，EINTR一般是continue，但问题就在于EAGAIN（意味着去read但是没有数据，如果read是阻塞不会返回EAGAIN而是一直阻塞，如果是非阻塞才会返回）了，epoll触发了你去读却没有读到数据，这显然不可能，那么原因是什么呢？EAGAIN往往发生在readn函数（即确保把数据读完的read封装函数）中，epoll可能以100B数据触发了，readn要读200B，当readn函数中的read函数读完这100B函数返回后，发现还有100B没读，再去读，此时剩下的数据还在网络上没有过来，那么read就会返回EAGAIN。








1 最后我们要讨论终极问题了，非阻塞readn函数如何和单多线程和三种触发模式结合？（根据回忆，我们有两个问题需要解决，一是要来了20B只读10B，二是要读10B来了5B）
先考虑单线程，
对于问题1，et下你需要把数据读到EAGAIN为止，可是问题是你怎么知道这个EAGAIN是由于网络原因返回的还是没数据了？————因而lt是合适的。
对于问题2，
不管是et还是lt，你都会返回EAGAIN，那么之后怎么办呢？
readn是返回一个状态码还是continue？
如果是continue，你怎么确定这不是恶意攻击或者用户断网导致本该发10B却只发了5B？————不能死continue，continue到一定次数就返回（这种解决方法lt还是et都无所谓）。
如果返回状态码，性能上损失过大（lt还是et无所谓）。

再考虑多线程，
对于问题1，多线程不能用lt，因而，你必须强迫自己去解决“EAGAIN是由于网络原因返回的还是没数据了“，我觉得方法还是不能死continue。
对于问题2，该问题同上。








# 最终问题汇总
0 et + 多线程场景下，如何应对发了1000B只读200B剩下的数据不触发的情况？有两种解决方案：一种是放弃et采用oneshot，一种是接着去读，读到EAGAIN，但是这这就到了第二个问题了：

1 readn函数如何应对要读200B只来了100B的情况？一是continue，但是continue会遇到问题那就是如果用户因为断网没发完，那么服务器的readn将陷入死循环，因此单纯的continue并不适用于生产环境，那么如何解决？两种方法：一种是放弃continue转而return，等待下次触发，但是这得写状态机，一种是设置一个超时时间，但是这种方法鉴于CPU运算速度远大于网络的传输速度，所以很难设置。

2 最终：要写状态机。

