0 端序、字节序（标准称呼）、尾序：在计算机的存储和传输中多字节对象的字节排序顺序。
例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&x的值为0x100，且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。



1 高地址、低地址：0x100, 0x101, 0x102, 0x103，小数是低地址，大数是高地址。（地址不是12345这种数，不要用左右去看待，要用高低去看待）



2 高位、低位：大数即左边是高位，小数即右边是低位。（用左右来看待）
例如一个int类型对象12345：
00000000 00000000 00110000 00111001
左边的就是高位，右边的就是低位。



2 字节序
大端：左边（高位的大数）的字节存在低地址，右边（低位的小数）的字节存在高地址
00000000 00000000 00110000 00111001
0x100, 0x101, 0x102, 0x103

小端：左边（高位的大数）的字节存在高地址，右边（低位的小数）的字节存在低地址
00000000 00000000 00110000 00111001
0x103, 0x102, 0x101, 0x100

# 直观看，大端是顺着来，小端是反着来。



3 网络字节序和主机字节序
（0）概念：字节序是由arch定义的顺序，但是网络字节序和主机字节序这个概念和arch无关而是TCP/IP协议栈规定的，目地是为了跨平台，TCP/IP协议栈规定网络字节序必须使用大端序。
（1）在网络编程中，为了让程序跨平台性增加，建议将TCP/IP协议栈的包头的多字节字段转为大端序：
`
#include <arpa/inet.h>
IP地址：
	主机转网络：
		uint32_t       htonl(uint32_t       主机IP地址);
	网络转主机：
		uint32_t       ntohl(uint32_t       网络IP地址);
端口号：
	主机转网络：
		uint16_t       htons(uint16_t       主机端口号);
	网络转主机：
		uint16_t       ntohs(uint16_t       网络端口号);
`



4 终极理解
上面的都是表层理解，你先知道，下面让我们回归概念理解网络序和主机序：在计算机的存储和传输中多字节对象的字节排序顺序，
注意是多字节对象，那什么是多字节对象呢？
一个序列化的结构体是吗？不是，真的不是（但是里面的int是），字符串是吗？不是，不管大端还是小端的arch对于序列化的结构体和字符串都是一视同仁的，
只有在存储int这种对象时，
最关键的点来了：arch会将int编码为4个字节然后按字节序计算、存储和传输，假设传到网络上的另一台主机，目地主机如果和源主机字节序不一样，解码就会失败，如果一样解码可以成功，
所以在跨平台开发中要约定好双方要使用什么字节序，
关于约定这个事，你先要知道字节序是可以约定的，先不说怎么约定，先来看看怎么通信？
怎么通信呢？假设A要想B发送数据：
A小B小：直接发；
A大B大：直接发；
A小B大：
我们先看看A不做任何处理发送：
A：
A要发送的原数据是12345（00000000 00000000 00110000 00111001），
A把原数据按小端序规则计算、存储、发送（这便是多字节对象的编码）：（0x01：00111001 0x02：00110000 0x03：00000000 0x04：00000000），
B：
B拿到（0x01：00111001 0x02：00110000 0x03：00000000 0x04：00000000）自然也是这么存，
B按大端序规则解码为959447040（00111001 00110000 00000000 00000000），
这显然错了，那么该怎么做？
A：
A要发送的原数据是12345（00000000 00000000 00110000 00111001），
【A把12345（00000000 00000000 00110000 00111001）转为959447040（00111001 00110000 00000000 00000000）】，
A把原数据按小端序规则计算、存储、发送（这便是多字节对象的编码）：（0x01：00000000 0x02：00000000 0x03：00110000 0x04：00111001），
B：
B拿到（0x01：00000000 0x02：00000000 0x03：00110000 0x04：00111001）自然也是这么存，
B按大端序规则解码为12345（00000000 00000000 00110000 00111001），
这下对了，思路说白了就是负负得正，哈哈，
A大B小：
A：
A要发送的原数据是12345（00000000 00000000 00110000 00111001），
A把原数据按大端序规则计算、存储、发送（这便是多字节对象的编码）：（0x01：00000000 0x02：00000000 0x03：00110000 0x04：00111001），
B：
B拿到（0x01：00000000 0x02：00000000 0x03：00110000 0x04：00111001）自然也是这么存，
B按小端序规则解码为959447040（00111001 00110000 00000000 00000000），
这显然错了，那么该怎么做？
A：
A要发送的原数据是12345（00000000 00000000 00110000 00111001），
【A把12345（00000000 00000000 00110000 00111001）转为959447040（00111001 00110000 00000000 00000000）】，
A把原数据按大端序规则计算、存储、发送（这便是多字节对象的编码）：（0x01：00111001 0x02：00110000 0x03：00000000 0x04：00000000），
B：
B拿到（0x01：00111001 0x02：00110000 0x03：00000000 0x04：00000000）自然也是这么存，
B按小端序规则解码为12345（00000000 00000000 00110000 00111001），
你会发现大到小，小到大都需发送端进行一步reverse，那么是否可以在接收端reverse呢？当然是可以的。
但问题是如果对端本来就是和自己一样的字节序，那么就不能转换，因而发送端怎么知道对端是什么字节序呢？
不用知道，约定！
约定大端序
A
if (大) {
    send
} else {
    reverse
    send
}
B
if (大) {
    recv
} else {
    reverse
    recv
}
