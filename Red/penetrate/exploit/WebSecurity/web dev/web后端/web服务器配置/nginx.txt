零 问题：
关于文件上传漏洞的问题：
1 不管有没有try_files，只要你配置了location，那么就能访问，而且默认就是$uri和$uri/（不管怎么都是在一级目录下寻找，那现在我问：/a/b是否被为/的location寻找，答案是会寻找）。
2 各个location没有顺序可言，会优先匹配最合适的，所以location /和location ~ \.php$在面对.php时谁起到了作用，我也不知道，我猜应该是location ~ \.php$，你想看出问题必须让而这不是一个根，但是根据尝试这不行。







一 ngnix是一台高性能的反向代理服务器和web服务器








二 和apache2 的区别是：它的默认目录在/usr/share/nginx/html（但是我不知道配置在哪）而不在/var/www/html（但是我却在/etc/nginx/sistes-available/default中能找见root为/var/www/html），这真是奇了怪了。
我估计是浏览器缓存问题，没有配置怎么可能找的见？配置了也就应该找见。







三 web服务的基本概念：
1 web服务：ip:port这代表了一个web服务。
2 虚拟主机：在计网原理中已经解释过了就是域名，每个server块就相当于一个虚拟主机。
3 分支功能：比如你访问https://www.wy.com/emp和访问https://www.wy.com/fg，你会发现路径不一样，这便是一个webapp的分支功能，每个location块代表了一个分支功能。
4 负载均衡：在计网原理中同样解释过，域名一样但IP不一样那叫负载均衡。







四 nginx的配置文件目录（/etc/nginx）
1 在这里目录中，有三个关于配置的文件和目录，分别是：/etc/nginx/sistes-available/、/etc/nginx/sistes-enabled/、/etc/nginx/nginx.conf。
2 /etc/nginx/nginx.conf是全局，一旦配置影响所有网站的所有路径。
3 sistes-available是可用的，sistes-enabled是启用的。
a 一般的做法是：当你需要管理多个网站时，可以将每个网站的配置文件放在 sites-available/ 目录中，然后通过创建符号链接到 sites-enabled/ 目录来启用它们。
b 好处：这种分离的设计使得管理和维护多个网站变得更加有序和灵活，因为你可以根据需要轻松地启用或禁用特定的网站配置，而无需修改主 Nginx 配置文件。
4 顺序：/etc/nginx/nginx.conf   ->   /etc/nginx/sistes-available/   







五 nginx的配置文件语法
（零）基本形式：
...              #全局块

events {         #events块
   ...
}

http      #http块
{
    ...   #http全局块
    server        #server块
    { 
        ...       #server全局块
        location [PATTERN]   #location块
        {
            ...
        }
        location [PATTERN] 
        {
            ...
        }
    }
    server
    {
      ...
    }
    ...     #http全局块
}



（一）/etc/nginx/nginx.conf：全局-events-http
1 全局块（影响服务器的整体）
user www-data;   # 用户
worker_processes auto;   # 进程数，一般设置为机器CPU数量的倍数，但是不宜太高，比如机器是8核，则设置为8或者16最多24。
pid /run/nginx.pid;   # 进程PID存放路径
include /etc/nginx/modules-enabled/*.conf;

2 events
events {
	worker_connections  1024;   # 每个worker_process允许的最大连接数（最大用户数），这个数量可以很大，nginx的性能是很不错的，据我所知epoll一般承载上万个连接是没有压力的。
}

3 http
（1）全局块：
a 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。
b 如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。
c 重点是upstream和resolver在这定义！
（2）server块：
可以嵌套多个server，但是不建议在这配置server，除非你希望nginx只代理一个网站，那样的话nginx的意义就丢了一多半。
（二）/etc/nginx/sistes-available：server->location
1 server块：
（1）概念：配置虚拟主机的相关参数，一个http中可以有多个server。
（2）server的全局块：
listen 80;   # 该虚拟主机的监听地址
server_name www.baidu.com;   # 该虚拟主机的域名
（3）location块：
a 概念：配置请求的路由及其处理方法。
b 基本格式：
location / {
    proxy_pass  http://backend_server;
}
c location（关于该字段的解释详见root字段）：有五种匹配方式：
第一种：精确匹配
location = /path/to/resource {
    // 配置规则
}
第二种：前缀匹配：
location /path/ {
    // 配置规则
}
第三种：区分大小写的正则匹配
location ~ ^/path/(regex|matches) {
    // 配置规则
}
第四种：不区分大小写的正则匹配
location ~* ^/path/(regex|matches) {
    // 配置规则
}
第五种：最长前缀匹配
location ^~ /path/ {
    // 配置规则
}
d 核心字段：
pass相关字段：这种字段负责把用户对某个location的请求交给某个web后端服务程序。有proxy_pass（为其他web服务器做代理） 、fastcgi_pass（这是主要使用的cgi，可支持php-fpm） 、uwsgi_pass 、scgi_pass 、memcahed_pass（缓存，应该是在内存中缓存） 、grpc_pass（RPC服务）等。
root（也可以在server全局块）：定义该路径的根路径（所谓根路径即指https://www.example.com/这个路径在哪，比如你把根路径定义为/var/www/html，那么，当你访问https://www.example.com/则去访问/var/www/html目录），定义了根路径后，你访问的location将在根目录下进行路由选择，比如你定义了根路径是/var/www/html，你的location精确匹配为/test/test.php，那么当浏览器访问https://www.example.com/test/test.php时，nginx将在/var/www/html目录下寻找test/test.php。
index：当你访问https://www.example.com/时，nginx会默认去根下按index字段定义的文件的顺序寻找index字段定义的文件，该文件往往作为网站的门户。
try_files： 一般格式为”try_files $uri $uri/ /fileback.php?$args;“，$uri代表用户请求的URI，$uri/代表用户请求的URI的目录（不递归），/fileback.php?$args是一个其他路由，其规则是，依据$uri按try_files定义的顺序查找即先查有没有这个$uri文件，如果没有则把$uri当成一个目录去这个目录下查有没有$uri这个文件，如果还没有，则去其他路由下查。
2 default文件：
（1）里面配置了”server_name _;“，”_“代表无名虚拟主机。
（2）该文件提供了对无名虚拟主机即没有域名的虚拟主机的访问，或者说如果找不见某个域名的虚拟主机，那么就来这，但是这不就是IP地址吗？因而禁用这个其实挺好的。
（3）禁用的方法是（光弃用default没用，你得return 444）：
server {
    listen 80 default_server;
    server_name _;
    return 444;
}



六 主要功能（其实就只有一个功能——反向代理）
（一）如何配置反向代理服务器（涉及配置虚拟主机，配置虚拟主机是最基本问题）（首先，nginx或者说HTTP层面的反向代理不是我们在计网中所说的反向代理，它本质上是正向，HTTP区分正反向代理的方式是按浏览器和服务器是否知晓代理的存在而区分的；其次，这个技术叫反向代理服务器）？
1 最基本形式：
server {
    listen       80;
    server_name  example.com;

    location / {
        proxy_pass  http://backend_server;
    }
}
2 



（二）动静分离
1 概念：动静分离，说白了，就是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用（.php、.war等文件）分开部署。
2 好处：我们当然可以使用PHP或者Java去访问静态资源但是这是没有必要的，采用动静分离让后台应用只负责动态请求，这样让网站的效率更高也节省开发时间，这已经实现了一些负载均衡了。
3 更进一步：在现代web开发中，更多的做法是，将静态资源放在CDN（DCDN甚至可以加速动态资源）甚至客户端浏览器上，大大提高对静态资源的访问速度。
3 如何配置静态路由？
location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {
        root static;   # 静态资源的根路径
        expires      30d;   # 这些静态资源在浏览器上的缓存失效时间，d、h、m、s。
}



（三）负载均衡（负载均衡就是多个反向代理）
1 upstream字段：
（1）假设你在http全局块内使用upstream字段定义了一个服务器群：
upstream backend_servers {
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;
}
server字段的选项：
weight：权重。比如：
upstream tomcats {
    server 192.168.0.100:8080 weight=2;  # 2/6次
    server 192.168.0.101:8080 weight=3;  # 3/6次
    server 192.168.0.102:8080 weight=1;  # 1/6次
}
max_fails、fail_timeout：失败次数，失败后多长时间弃用它。比如：
upstream tomcats {
    server 192.168.0.100:8080 weight=2 max_fails=3 fail_timeout=15;
    server 192.168.0.101:8080 weight=3;
    server 192.168.0.102:8080 weight=1;
}
backup：备份机，所有服务器挂了才生效。
max_conns：限制分配给某台server的最大连接数。
resolve：与http全局块内的resolver配合使用。比如：
resolver 10.0.0.1;
upstream backend_servers {
    server example.com resolve;
}
（2）你可以在proxy_pass字段上根据upstream字段定义的服务器群定义多个反向代理，形式为：proxy_pass http://backend_servers。
（3）还有其他的方式，但是需要第三方插件。



七 例子
（一）一个配置ws的例子：
location /emp3r0r {
    proxy_pass http://127.0.0.1:9000/ws;   # 需要修改你的ws服务
    proxy_redirect off;
    proxy_http_version 1.1;   # 配置被代理的web服务的http的版本
    proxy_set_header Upgrade $http_upgrade;   # 和proxy_pass有关的关键字段：可以修改原HTTP报文首部的字段
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $http_host;

    # Show realip
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}



（二）一个配置php-fpm的例子
location ~ \.php$ {
    root /home/www-data/www;   # 需要修改为你的根目录
    fastcgi_pass unix:/tmp/php-fpm.sock;   # 需要修改为你的php-fpm.sock路径
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    include fastcgi_params;
}



（三）一个可用的动静分离的模型
server {
        listen 80;
        server_name emp.wywywy.fun;
        root /var/www/html/;

        location / {
                index index.html;
                try_files $uri $uri/ /fileback.php?$args;
        }

        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {
                root /var/www/html/;   # 静态资源的根路径
                # expires      30d;   # 这些静态资源在浏览器上的缓存失效时间
        }

        location ~ \.php$ {
                root /var/www/html/;
                fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
