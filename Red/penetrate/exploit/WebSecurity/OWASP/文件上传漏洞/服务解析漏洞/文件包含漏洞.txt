零 
1 该漏洞在php语言开发的项目中极为常见。（功能越强大漏洞就越多）
2 该漏洞有其两个作用：
（1）可作为文件上传漏洞的第三步的辅助，帮助解析黑客上传的木马。
因而，已经通过文件上传漏洞上传了木马过去，这个木马也许不是php结尾的，而是jpg等，也没有关系，文件包含漏洞就是用来解析非php结尾的文件的。
（2）可作为独立的漏洞进行利用。（日志包含漏洞）







一 漏洞成因（原理）
（我无法理解，这很扯淡，为什么后端要让前端指使自己去包含前端传过来的文件，这不是引狼入室吗？）
<?php
    $file = $_GET['file'];
    include $file;
?>







二 测试姿势
（一）如何发现测试点？
思路：在前端看到有让前端传入文件名但这个文件名不是前端文件的，就可能存在文件包含漏洞。
比如：“http://192.168.43.223/pikachu/vul/fileinclude/fi_local.php?filename=file5.php&submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2#”这条URL经过分析发现，file5.php不是前端文件，但却是由URL进行输入，可见存在文件包含漏洞测试点。当然这个例子太清晰了，直接是php文件，如果不是php文件其实也可以测试因为我们只要确保我们要访问的页面（这里是index.php）include了这个文件就行而无关它的后缀名。



（二）设计poc及测试：
1 独立使用（日志包含漏洞）：
（1）首先先认识一下日志：
a web服务器的日志一般有两个：error.log和access.log，这个access.log会记录用户所有的数据。
b access.log一般都是开着的，这是因为中国有着严格的内容审查制度。
根据这一点，我们就可以注入木马程序到access.log中。
（2）日志包含漏洞：有两种情况：
a 如果某个php页面正好包含了access.log了，那么，黑客就可以通过访问这个页面。
b 存在文件包含漏洞，你可以在前端包含access.log文件。
针对b，还需要两个条件：
目录越权漏洞且在默认位置（不在你就得找到它）：access.log默认位置：Linux：apache2：/var/log/apache2/access.log，nginx：/var/log/nginx/access/log。
root权限：一般只有root权限才能访问/var/log下的目录但是大概率管理员会修改掉权限，如果正好修改为了777（不一定是这总之就是web服务器用户正好能对该目录具有权限），那对黑客而言岂不乐哉？

2 作为文件上传漏洞的辅助：
（1）本地包含
条件：这个漏洞不受allow_url_fopen = On和allow_url_include = On这两个的影响。
（2）远程包含
条件：这个漏洞受allow_url_fopen = On和allow_url_include = On这两个的影响。
（3）伪协议（不是真正的协议但是使用协议的格式）：这个方法可用来做很多事情，不一定是解析php。（假设漏洞点是page=）
a 利用php伪协议读取php文件的源码：page=php://filter/read=convert.base64-encode/resource=目标php文件
b 利用php伪协议RCE：
page=php://input
请求体：<? php system('ls');?>







三 防御和绕过
（一）只include php文件而不include其他文件。
1 一个常见的做法是：
<?php
	if (isset($_GET['page'])) {
		include $_GET['page'] .".php";   // 把所有的从page拿来的文件名加上.php，正常来讲后端有一个1.php，那么前端应该输入page=1，但是如果黑客上传了2.jpg，那么黑客将无法构造page以让目标页面include 2.jpg，除非黑客的木马就是php结尾的，但是这是另一个漏洞了（文件上传漏洞）。
	} else {
		include 'home.php';
	}
?>

2 绕过方法是：%00截断
page=2.jpg%00
（二）str_replace