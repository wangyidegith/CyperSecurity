零 在我看来，这是最简单粗暴的漏洞了。







一 漏洞成因（原理）：一个完整的文件上传漏洞应该包括三方面（这里涵盖一些前置知识）：
（一）可以文件上传：
有的webapp就包含文件上传功能，如果他没有做好检测和解析那么就有可能存在文件上传漏洞，亦或者是某些配置失误导致目录可以文件上传（这样的目录需要你去fuzz）。



（二）你可以访问到这个文件：
这个文件既然能上传到服务器上，那么，也就是意味服务器上的当前用户势必对保存文件的目录有着全部权限（能在一个目录里写入文件意味着该用户对该用户拥有7权限），那么肯定也是能访问到的，但是你不一定直到这个文件在哪啊，所以这时候往往需要fuzz。



（三）上传后的文件可以被作为一个asp、php、jsp进行解析：
这里往往配合服务解析漏洞。







二 测试思路
[一] 明确漏洞点：漏洞点就是文件上传功能或者也可能是你fuzz到的目录

[二] 设计exp并测试：
（零）准备木马文件和rat：
1 木马文件：<?php eval($_POST['ant']); ?>
2 rat：蚁剑常用，但是菜刀更牛逼，哥斯拉和冰蝎不行。



（一）上传木马文件（前端防御URL不会有刷新且很快，后端一般会刷新URL且慢）。
1 前端绕过姿势（任何前端的限制对黑客而言根本不能叫限制）：
（1）删掉限制语句。
（2）bp抓包然后再改。

2 后端绕过（有很多防御方式）：
（1）MIME检测：
a 一般是白名单，一般上传图片比较常见，有image/jpeg 、image/png 、image/gif 、image/jpg等。
b 绕过姿势：前端改了Content-Type就行了。
（2）黑名单（白名单道理也一样）：
a 比如：$deny_ext = array('.asp','.aspx','.php','.jsp');
b 绕过姿势：这就很难通过简单的修改某个字段来绕过了，目前有三种方法：
第一种：前提是存在服务解析漏洞。
比如文件包含、IIS的分号（test.php;.jpg）、apache的AddType application/x-httpd-php .php或AddHandler php5-script .php，nginx的cgi.fix_pathinfo 1。
第二种：
前提是存在Windows系统
方法一：冒号（test.php:.jpg）配合Windows文件命名环境的叠加特性（test.<   test.<<<   test.>>>   test.>><）。这种方法的问题在于：对于那些会给上传文件改名的后端程序而言，test名字就变了，怎么去猜测到test这个名字呢？
方法二：Windows后缀名不区分大小写。
方法三：Windows后缀名会省略" ."和". "，比如"test.php ."、"test.php. "。
方法四：Windows后缀名会省略”. .“。
方法五： Windows后缀名可以写成：test.php::$DATA，这是基于mtfs的文件流特性来玩的，Windows一看后缀有”::$DATA“，就会把文件的输入内容（在HTTP通信中就是请求体）写入前面的文件中。
Windows和Linux都可以：
test.php/
第三种：前提是没有过滤.htaccess。
第一步：准备一个文件名为.htaccess的文件，内容为：
<FilesMatch "">
SetHandler application/x-httpd-php
</FilesMatch>
第二步：将.htaccess文件上传到后端，如果能上传那说明黑名单检测不严格。
第三步：将图片马上传到后端，因为.htaccess的存在该图片马可以被解析。
第三步有两个问题：一是隐藏在图片里的马能不能被解析？（我才应该是能的，要是不能文件包含还怎么玩？）二是我在upload-labs上传的.htaccess不能解析（该问题已解决，注意不要）。
（3）有的php后端会这么写：$file_name = str_replace($deny_ext,"", $file_name);，即把符合黑名单的文件的后缀名去掉。
绕过姿势：把test.php改为test.pphphp。
（4）竞争漏洞：
时间竞争漏洞：
背景：很多后端程序考虑到并发量并不会串行执行上传文件的检测等后续操作而是将用户上传的文件不管三七二十一存到一个临时目录中然后就响应，再使用其他的线程处理（检测、删除、移动（move_uploaded_file）等）临时目录中的文件。
原理：根据背景，可以打一个时间差，黑客要在上传文件被删除之前就访问上传到临时目录中的木马文件继而触发该文件的代码，而该木马文件的功能文件往往是创建一个内存马并回连RAT。
注意：你需要首先发动cc攻击，增大并发量，以让后端临时目录中的积压文件有更多的存储时间。
重命名竞争漏洞：
背景：同时间竞争的背景，在一个合格合规的高并发里，后端程序根本不可能在IO线程里做任何数据处理，重命名也是在其他线程里进行的。
原理：这种攻击的主要目标是为了对抗改名，因为一旦改名，那么后期fuzz找目录会浪费很多时间，利用这个漏洞可以在改名之前就访问到木马。
问题：在https://www.bilibili.com/video/BV1Yy411Y7C8?p=8&spm_id_from=pageDriver&vd_source=614e71a27354c32bb64f01a439f3391b中，我看到了：在大量并发请求下，靶场的改名线程出现了漏操作，这是怎么回事呢？根据我写多线程和线程池的经验，一个在条件变量和互斥锁控制下的消息队列在高并发下会慢但根本不可能出现漏操作，有没有可能是队列满了，IO由于不能停，就没管这个新文件，我以前写的是让IO停一下，原来漏洞出在了这。
（5）getimagesize检测：
a 该函数用于获取图像的大小及相关信息，成功返回数组失败返回false并产生一条E_WARNING级的错误信息。
b 绕过姿势：一个前提两种绕过方式：
一个前提：文件包含漏洞。
两种绕过方式：
第一种：用bp在木马文件开头加个GIF89A。这种方式不是很好，因为后端有可能检查的很详细。
第二种：将木马隐藏到图片里：copy /b 木马+图片 新图片。也能使用工具edjpgcom.exe。（存疑：好像不能被解析。也许菜刀能成功？）



（二）找到文件的位置
1 找位置的原因有二：
（1）你不一定知道文件的路径（实际上大概率不知道除非后端采用了URL下载方式）。
（2）文件名有可能被改变。
2 如果你先fuzz目录，要注意：很多目录会配置index，这还不错，但是有的不配置，那么就会返回403，因而当你fuzz到一个目录是403时，那么说明你找对了目录。







四 防护
（一）fuzz是防不了的，只能在检测和解析上下文章。



（二）怎么不让解析？我的想法是：都是只解析固定的php文件：
1 只在在根处的index.php文件里解析其它地方都不解析。
（1）用= /而不用前缀根；
（2）不解析.php结尾的文件；
（3）只在= /下解析index.php，所有其他的php文件通过include的方式包含进index.php文件。

2 只解析一个php文件。
server {
        listen 80;
        server_name emp.wywywy.fun;

        root /var/www/html/;

        location / {
                index index.html;
                try_files $uri $uri/ /index.php?$args;
        }

        location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|js|css)$ {
        }

        location = /index.php {
                fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                include fastcgi_params;
        }
}
