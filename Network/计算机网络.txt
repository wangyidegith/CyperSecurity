第一章 概论
一 基本概念
1 三网：电信网（电话） 有线电视网 计算机网络
2 印刷机
3 作用：连通性 资源共享
4 主机（host）：在网络中的位置是终端，主机名，dns
5 （重点）概念辨析：互联网（Internet，专指目前人类使用的以TCP/IP协议栈为标准的互连网） 互连网（internet，网络的网络） 网络（最简单的二层网络，网络的网络都是网络）
6 标准化：Internet Society（ISOC，1992年Internet不归美国政府管辖后便归该组织管理）->互联网体系结构委员会（IAB，ISOC的主要技术部门，负责协议开发）->互联网工程部（IETF）和互联网研究部（IRTF），RFC（Request for Comments，由IETF管理）记录了所有的Internet协议。
7 计算机网络的两个基本元素：节点（结点，node），链路（信道，link）。
二 拓扑结构
1 （重点）阶段：1969年美国国防部研发的第一个分组交换网ARPANET->1983年（互联网元年）TCP/IP协议栈成为ARPANET的标准协议，标志着Internet的诞生->1985年美国国家科学基金会NSF建设了NSFNET，是一个三级网络结构（主干网，地区网，园区网（当时主要是校园，因为该网络主要服务于美国的大学和科研机构）），NSFNET随即成为Internet的主要网络->1992年，美国政府转移Internet的经营权给商业，Internet开始正式商用，原先主要服务于美国大学教育的Internet的主要网络NSFNET开始被各大ISP建设的网络取代，Internet开始迎来大发展。
2 （最重要）ISP是互联网服务提供商，这里要区分，百度、腾讯、阿里他们是ISP吗？不是，他们提供的是基于互联网的应用服务而非互联网服务（他们是ICP（Internet Content Provider，在阿里云上可看到ICP备案，就是让网站拥有者去工信部备案自己的域名）），在中国，互联网服务是由三大运营商提供的，三大运营商才是ISP，换言之，他们的位置在Internet的边缘而非核心，他们的网络IP是私网IP而非公网，当然他们有公网IP，但是那也是他们向ISP租用的。
3 所谓上网就是获得一个IP地址。
4 一般认为，本地ISP（园区网）作为边缘网络向另一个园区网通信时要经过地区ISP（地区网）再经过主干ISP（主干网），但是实际上地区与地区之间也可以直接通信，二者连接点叫IXP（互联网交换点），比如德国法兰克福的IXP已经成为欧洲的数据通信枢纽。
5 （最重要）接着2，从拓扑上看，Internet分为了边缘和核心，
其中核心就是一个分组交换网，从分层体系结构角度来看，它仅包括下三层，它的主要设备是路由器，所谓分组交换，
不同于电路交换（电信网，建立连接>独占端到端的带宽资源->释放资源），分组交换逐段占用传输带宽，
也不同于报文交换（邮件，完整的报文），分组交换传输的并不是完整的应用报文，也非TCP报文段和UDP用户数据报，而是IP数据报；（分组即数据包（packet），简称为包）
其中边缘包括五层，也就是我们常说的主机或者端设备，边缘的主要工作是数据处理、存储和通信，它做了比核心更多的事情，也就是说Internet遵循一个原则“边缘复杂，核心简单”，核心只负责通信，而边缘则可以研发复杂多变的应用程序，
边缘除了负责进程区分、屏蔽网络细节和可靠性的传输层以外，应用程序主要分为两种架构，C/S（server一直运行client不一定，server必须有公网IPclient不一定，server被动接收client的请求继而响应数据）和P2P（一个机器既是client又是server，这个技术主要是涉及打洞，而打洞涉及TCP、UDP、NAT协议）。
三 七个性能指标
1 速率（数据传输（送）率，数据率，比特率），最高速率叫额定速率或者标称速率，其定义是每秒传多少比特的数据，至于说谁传，那这就取决于要分析谁了，
（重点）速率的单位是bit/s，简写为bps或者b/s，kbps，Mbps，Gbps，Tbps，P，E，Z，Y，它们之间的换算关系是乘10的三次方，主要是k，M，G，T用的多，你大概需要知道1M是100万，另外，你应该发现了，除了k是小写其它都是大写，另外，很多地方会简写单位，比如1kbit/s简写为1kbps或者1k/s，甚至写成1k，比如我们说带宽50M，实际上指50Mbit/s；
（重点）注意区分速率单位和存储单位，存储的单位是一般是B而非b，比如在开发中我们经常说开一片1024B的缓冲区，KB，MB，GB，TB，PB，EB，ZB，YB，它们之间的换算关系是乘2的10次方，主要是也是K，M，G，T用的多，另外，你应该发现了，这里全部大写，另外，存储单位的简写一般会省略B。
2（重点）带宽：模拟信号的带宽是信号的频带宽度，数字信号的带宽是最高数据传输率，就是额定速率，我们一般说的是数字信号。
3 吞吐量：实际数据传输率。
4 时延：传输（送）时延（数据量/速率）+传播时延（传播距离/光速）+排队时延（路由器的存储产生）+处理时延（路由器的处理产生）
5 往返时间RTT
6 利用率（一般指信道利用率，网络利用率指各个信道利用率的加权平均）：有个公式U=1-空闲时延/当前时延，我不知道这是怎么得出的，但是通过该公式可以看出，当网络的利用率过高时，时延会变大，因而一些主干网不允许利用率超过50%，一旦超过就要考虑提高带宽。
四 体系结构（也叫分层体系结构或者计算机网络模型，这个点是整个计算机网络这门课中最重要的点，说白了就是如何从开发的角度认识计算机网络）
1 协议是什么？说白了就是一个程序，程序就是算法+数据结构，数据结构是协议语法，即协议包的格式，其实就是一个带着柔性数组的结构体，作为协议数据单元或者服务数据单元（二者是同一事物在不同角度下的不同叫法），算法是协议的语义和同步（时序），语义是程序的算法本身，同步也是指算法，但是指对等方如何共同协作的算法，比如client发了请求数据，server收到后，根据数据的情况决定响应什么数据，这是语义，这里client先发数据而后server再进行回应这就是时序。
2 实体、协议、服务（封装和解封）、服务访问点概念辨析：
实体就是协议程序中的进程；
协议就是程序，就是算法和数据结构；
服务是从上下而非对等的角度看待协议，首先要明白在体系结构中，任一层从上层接收数据，在本层封装成本层的协议包后交给下层，任一层从下层拿到本层的协议包，解封后拿出数据交给上层，其次从开发角度看，一个简单的协议程序的头文件除了要有一个结构体和相关宏定义，一般会有四个函数，初始化和释放函数，发送数据函数（内部是封装函数）和接收数据函数（内部是解封）；
服务访问点：上面说到的两个关于封装和解封的函数其实就包含了访问点，发送函数往往会有一个参数用于接收用户数据，内部封装后通过socket交给下层协议，接收函数从socket接收数据并通过一个传出参数将数据给到上层用户，所以有四个访问点。
3 五层模型（TCP/IP协议栈）、OSI七层模型。
4 对于协议包格式（协议语法）的另一面的认识：
协议包的格式其实就是一个带着柔性数组的结构体，但是这是从存储的角度认识的协议包格式（协议包格式是结构体，比如我们使用这个结构体定义一个结构体对象，这个对象是存在内存中的）。
那么从通信的角度看呢？这个结构体对象总要发到网络上或从网络上收到的。
这就是我要说的另一面了：
一个表示协议包的结构体对象要发送到网络上必须先转成字节流（物理层是一个比特一个比特发送的那也就是一个字节一个字节发送的，这就是为什么要转成字节流）作为write函数的void* buf参数，由结构体对象转字节流的这个操作叫序列化（encode）。
反过来一个程序从网络上read到一个void* buf，这里面是字节流，作为程序员你得把字节流转成结构体对象，这叫反序列化（decode）。
再往深处想：
我在安卓开发的时候首先就强调了server端和client端不一定非得是同一门语言写的程序，那么原因是什么呢？因为不管什么语言都认识结构体这种数据类型。
但问题是对于应用层的数据如果他也有格式呢？比如form类型，那就得由程序员进行编解码（en/decode）了。
另外，OSI七层模型定义的表示层就是专门用来做针对应用层数据格式的编解码的但是这个在企业开发中没有被践行，有的数据格式在该层进行比如form格式但有的比如JSON格式在应用层进行，这也是为什么很多人都不对上三层做区分的原因。
在MIME类型格式（目前最被广泛应用且作为HTTP标准的数据格式表示法）中，JSON格式一骑绝尘已经成为最常见的应用层数据格式（这个应用层是真的应用层，就说text/html也应用广泛但是我们按OSI七层模型来看这是表示层，哪怕form也是表示层但和text/html也不是一层，但是它们都是MIME，所以我们就随大流不要刻意在意OSI的上三层划分就行了，只要知道它们不在一个层面编解码就行了）。






第二章 物理层（这一层其实就是通信工程，它是另一个专业了，这一层是纯粹的硬件，除了专门研发通信设备的工作，目前我能想到的就是安宽带了，还有弱电）
一 （重点）基本概念：
1 消息（message）、数据（data）、信号（signal）
message：information是更大的概念，message是更通俗的说法，文字、图像、音视频等都是消息，也可以认为message是information的payload。
data：运送消息的实体，RFC4949的定义是数据是对信息的符号表示。
signal：数据的电气或电磁表现（又叫电信号），基本单位是码元，分为了数字信号和模拟信号。
2 单工、半双工、全双工
3 信号的具体解释：
（1）数字信号也叫基带信号，模拟信号也叫频带信号（射频信号）；
（2）数字信号->模拟信号是调制（带通调制），模拟信号->数字信号是解调；
（3）调制解调器就是modem，俗称“猫”，但是这里有一个问题，我们经常说的“光猫“，是转换光信号和数字信号用的；
（4）数字信号也可以调制为数字信号（基带调制，更通俗的一个叫法是编码）：不归零、归零、曼彻斯特、差分曼彻斯特；
（5）带通调制有调频、调幅、调相三种基本的方法。
（6）任何通信系统的信号基本上都包括三个过程：编码、加密、调制，反之是逆过程。
4 串行：
计算机内部的数据传输是并行的，目前为64位，也就是说CPU的总线一次性传输64个比特的数据，但是在和网络通信时不可能搞64根线传输数据，为了节约成本，网络传输媒体往往一次性只能传输一个比特的数据，这也就是串行传输，因而总的来说，CPU是并行的而网络是串行的，所以CPU的速度要比网络IO快的多的多；
计算机和IO之间的接口有一套统一的国际标准USB，比如鼠标键盘U盘硬盘等用的type a，打印机扫描仪等用的type b，现代智能手机的数据线充电线等用的type c，之前安卓机常用micro usb，苹果早期曾使用lightning。
二 信道的极限容量
三 第0层（传输媒体，传输信号的层）：
1 导引型：双绞线（铜线，rj45接口）、同轴电缆（铜线，模拟信号，速率低，已几乎不再使用，主要用于有线电视网）、光纤（原理是有无还是角度，应该是有无，速度非常快，用于架构主干网）
2 非导引型：短波穿透能力强但是不见得它就好，它对人体有害且传输本身也不好，紫外线以上的波通信中不用，光纤是可见光，5G（地面微波接力通信，构成的网络叫蜂窝移动通信网）和卫星用的都是微波，WiFi是无线电。
四 信道复用技术
五 数字传输系统：sonet/sdh（国际通用的光纤传输标准）
六 宽带接入技术（接入网，不是边缘也不是核心，从网关到边缘路由器之间的网络）
1 ADSL：上行慢，下行快，这符合网络上数据的突发性特点。
2 HFC：光纤技术与同轴电缆相结合
3 FTTx：对光纤入户（普通家庭不需要那么大的带宽）的改进，共用光纤。



第三章 数据链路层（工作岗位主要集中在网卡生产厂商或者物联网设备生产厂商，还有网络规划设计，网络安全工具的开发）
一 基本概念
（一）链路就是传输媒体，是物理层概念，数据链路是在物理媒体上增加上通信协议。
（二）网卡拥有下两层，所谓网卡就是网络接口，就是MAC地址和IP地址所标识的东西。
（三）三个基本问题
1 封装成帧
两个问题：
（1）不管帧格式怎样，帧都有首部和尾部用来做帧定界；
（2）（重点）最大传输单元（MTU，Maximum Transfer Unit）：帧的数据部分长度（IP数据报）上限。以太网的MTU是1500B（最小是46B），Internet的MTU是576B。
2 透明传输
数据部分出现了帧定界符怎么办？加转义字符。
3 （重点）差错检测
首先差错检测是计算机网络中的一个核心问题，任何物理媒体和网络的传输都不能保证绝对的不出错，因而物理层之上的数据链路层为上层提供了比特级别的差错检测或可靠性，网络层之上的TCP为上层提供了字节级别的可靠性；
其次数据链路层的可靠性保证只差错检测或保证比特不出错（即0不要传成1，1不要传成0），并不解决帧的丢包、乱序、重复，这叫“无比特差错”，TCP解决包级别的可靠性，这叫“无传输差错”；
最后在数据链路层，差错检测是一定做的，CRC也就是只做检测，那么如果出错，我们在上面说“差错检测或可靠性”，OSI规定数据链路层应该保证比特级别的可靠性，即发现某个帧的比特差错后能够采用重传确认等机制解决错误，保证每个帧向上提供的数据是没有比特错误的，但是事实上，现代通信链路（尤其是有线信道）的误码率非常低，采用重传等可靠性机制降低了通信效率，因而Internet的数据链路层对差错采用区别对待的态度，在误码率非常低的有线链路上如遇差错则直接丢掉包让TCP和应用层负责可靠性保证，在误码率较高的无线链路上则保证可靠性。
从信道的两个角度认识该层，点对点和广播，有线和无线。
（四）网段：
按照维基百科的解释，网段是物理层概念，是一个冲突域，是最小的网络，这里外国人普遍认为的；
中文的网络入门知识经常认为网段是同一个网络号的IP地址集合。
（五）接口：
其实只要是个口就是接口，比如我们经常会写接口函数，socket就是一个经典的接口函数，端口也是接口啊，但是在计算机网络中为了明确起见，我仅将网卡称为接口，也就是说，接口是网络接口的简称，端口不叫它接口。
二 点对点和有线广播
（一）点对点信道
ppp协议（hdlc协议保证可靠，但已被废弃）：这个协议非常简单，格式主要就是首协议类型数据校验尾，采用字符填充或零比特填充实现透明传输。
（二）有线广播（局域网，一般认为广播才叫局域网）
1 以太网在MAC层采用MAC协议和CSMA/CD协议，LLC层是逻辑链路层，比如一些认证协议属于该层。
2 CSMA/CD协议：有线局域网在实现上可以只使用物理层的信道复用技术，但是该技术无法适应复杂的网络环境，因而在有线局域网一般不复用信道，数据链路层协议控制多台主机对单一信道的访问，这就是随机接入协议中的CSMA/CD协议（令牌环协议没有这个好），在LLC层使用这个协议的有线局域网就是著名的802.3以太网，一个以太网就是冲突域（碰撞域）。
3 （重点）MAC协议：
（1）48位的MAC地址可唯一标识世界上的唯一一个网络接口；
（2）前三个字节由IEEE的注册管理机构定义分配给每个网卡生产厂商，剩下的由厂商自己定义；
（3）MAC协议也可以广播和多播；
（4）帧格式：7B前同步码1B帧定界开始符（这两个由硬件加上不属于MAC帧结构）6B目的MAC地址6B源MAC地址2B类型（标识上层协议）46B-1500B的数据4BFCS数位空闲
（5）帧格式中没有长度，因为不需要长度：以太网使用曼彻斯特编码，物理层可以判断到哪里结束，前同步码和帧定界符的意义也不是为了定界，而是为了时钟同步（？），sdh不需要前同步码，因为它本来就保证了同步；
（6）（重点）以太网中的网卡可以开启混杂模式（promiscuous），即监听网络中的流量，这事实上是一种攻击手段，叫sniffer（嗅探），但是也可以用来抓包做研究。
4 集线器hub是一个物理层设备，只负责中转信号（有的也有一些网络管理和少量的容错能力），和集线器类似的设备是中继器；
集线器的目的是为了让线路容易管理，形式上呈现为星形，但本质上还是总线。
除了便于线路管理以外，集线器的另一个功能是扩展以太网（为什么需要扩展？因为以太网上的链路鉴于CSMA/CD协议不能太长，一般不能超过200米，长了会让CSMA/CD协议失效），实际上这和现代建筑的综合布线的普及分不开关系。
5 除了集线器这种在物理层扩展以太网的方式，还可以在数据链路层扩展，即交换式以太网，当然交换机的诞生不光是扩展了以太网的大小，更为其增加了很多好处；
交换机的工作原理是自学习，第一次发则记录（MAC地址，接口）并广播，后面发往该MAC地址的帧就从该接口转发；
兜圈子问题（环路问题）：生成树协议（STP）；
交换机网络也叫以太网，因为它也用的是MAC协议，但是它显然不需要像总线型以太网那样解决冲突问题。
6 （重点）VLAN（802.1Q）
VLAN实际上MAC协议的改进版，它是另一个协议，而不是在MAC协议上的LLC层进行了设计，理解这一点至关重要；
改进在于在MAC帧的源地址后增加了一个4B的VLAN标记字段，其中第三个字节的第5位开始的12位时VLAN ID用来表示该帧属于哪个VLAN；
VLAN可以用于搭建内网实验环境，我们不至于为了做个测试而专门搞个内网，但是可以用VLAN在原有网络基础上搭建一个VLAN作为内网。
7 pppoe：使用以太网作为宽带接入网。
8 以太网是有可能引发广播风暴的，尤其是总线型以太网，广播风暴可以作为一种攻击手段，交换式以太网虽然减少了可能性，但是也可能引发广播风暴，VLAN最大限度地避免了广播风暴。
三 无线网和移动网（这一块内容涉及WiFi和5G，和我们的生活息息相关，从2008年左右，世界开始进入移动互联网时代，即边缘子网的主要网络形式由有线转为无线）
（一）无线局域网WLAN
1 分为两类：无固定基础设施的（WiFi）和有固定基础设施的（IoT网络，即无线自组网，无线传感网WSN）
2 WiFi：这是一个相当复杂的技术，如果不是专门做WiFi开发，只需要了解一些基本概念即可。
（1）802.11；
（2）星型拓扑；
（3）AP（叫接入点：微波基站、无线路由器、手机热点）；
（4）一个AP所管理的一个无线局域网叫基本服务集BSS；
（5）一个BSS所覆盖的地理范围叫基本服务区BSA，WiFi的BSA的直径一般不超过100米；
（6）当网络管理员安装AP时，必须为该AP分配一个服务集标识符SSID；
（7）多个BSS提供分配系统DS构成更大的扩展服务集ESS；
（8）一个移动站接入AP的过程叫关联；
（9）WPA2（重点）：当前的WiFi认证标准，所谓认证就是登录WiFi的过程，任何一个现代人应该都知道连WiFi需要密码；
a WiFi认证协议进化史：
（a）WEP（Wired Equal Privacy）：早期WiFi认证协议，其实就类似于我之前写过的那个基于UDP的广播程序，采用AES这样的对称加密算法，加盐（IV），但是WEP的最核心安全问题在于IV只有24位（我之前的IV是256位），24的IV可以产生16777216种盐，显然这不够多，破解WEP协议的WiFi密码正是利用了此密码学漏洞；
（b）WPA（WiFi Protected Access）：和WEP使用的算法一致，但是更健壮；
（c）（重点）WPA2（不要看它和WPA名字很像，它可没用WEP的算法）：
它采用了一种四次握手的方式来对用户进行认证，具体过程如下：
首先先说明一些概念：
WiFi密码就是PSK（Pre-Shared Key，预共享密钥），PSK、SSID、SSID长度、哈希迭代次数、要生成的共享密钥（PMK）的长度（这五个生成要素是客户端和AP都知道，不需要通信）通过某种哈希算法共同生成了PMK；
PMK（Pairwise Master Key，对主密钥）、客户端生成的瞬态随机数（Snonce）、AP生成的瞬态随机数（Anonce）、客户端的MAC地址、AP的MAC地址，这五个生成要素随机数是要通信才能得到的，MAC地址也需要ARP，因而为了交换这些数据，就有了四次握手，生成的目的是为了通过某种哈希算法生成PTK（对瞬态密钥，Pairwise Transient Key，用来加密AP和客户端之间的流量）和GTK（组瞬态密钥，Group Transient Key，用来加密广播流量）。
其次四次握手的过程：
注：以下简称客户端为STA（station）。
前置阶段：在握手之前，客户端和AP已经建立了关联了。具体说，STA通过自己的无线网卡去scan或者说探测附近哪里有AP并向该AP发起认证请求，这个认证的目的是为了认证以下对方是不是802.11设备并得到SSID、MAC地址等基本信息，AP向STA响应认证响应表示允许建立关联；然后STA向AP发起关联请求，关联的目的是为了协商认证协议、加密算法等，在这个认证关联的阶段，STA会算好PMK。
第一次握手：AP向STA发送Anonce；
第二次握手：STA收到Anonce后，算好PTK，根据PTK算一个指纹MIC（Message Integrity Code），将MIC和Snonce发往AP；
第三次握手：AP收到STA发来的MIC和Snonce，AP这时间也受到了Snonce了，算出PTK继而算出MIC，如果不一致，那么只能是某一方的PMK不对，而决定PMK又是WiFi密码，AP的WiFi密码不可能错，所以AP就会认为STA输入了错误的WiFi密码继而中止，如果一致那么AP生成一个GTK，将GTK和MIC发给STA；
第四次握手：STA回复MIC表示拿到了GTK。
在四次握手中，AP和STA都成功拿到了PTK和GTK，就此它们可以加密地通信了。
最后，你有没有发现一些涉及网络安全的问题：
简要总结四次握手，WiFi密码和SSID生成PMK，PMK、双方nonce、双方MAC地址生成PTK，PTK生成MIC，你是否发现了一个惊天秘密：除了WiFi密码以外，MIC和所有计算MIC的数据比如nonce、MAC地址、SSID等都是在网络上传输的，于是我们是不是可以截获一次完整的四次握手，拿到MIC及nonce等所有计算MIC的信息，然后使用暴力破解的方式，猜测WiFi密码呢？是的，这就是aircrack-ng等工具破解WiFi密码的原理。
那么，如何防御这种攻击呢？看上去使用强密码是唯一的还不能确保防御成功的方法。事实上，大多数个人网络比如家庭网络或者某个小餐馆、小酒店、小KTV台球厅咖啡店等场所确实容易被破解WiFi密码，因为它们使用了固定的WiFi密码，这一点作为APOL（四次握手）协议的漏洞无法弥补。于是很多企业为了对抗这种攻击在四次握手的基础上增加了一个RADIUS（远程访问拨号用户服务器）及相关的访问管理协议（统称RADIUS协议），我之前在厦门理工登录学校校园网的WiFi时就不是输入WiFi密码而是登陆网页输入自己的学号和密码，这正是RADUIS协议，好处在于每次你连接WiFi使用的PSK是RADIUS临时给你分配的，就算是黑客破解了也没用啊因为这时候这个破解到WiFi密码早失效了，这就像我们现在常用的登录验证码一样仅用于本次登录。
（10）CSMA/CA协议；
（11）（重点）WiFi使用的是无线电信号，该信号的穿透效果在电磁波家族里效果最差，因而为了让室内WiFi的信号最好，最好让AP的位置【居高居中】。
（二）无线个人网WPAN
1 蓝牙（范围大概在10米）
2 zigbee（一个经典的低速自组网）
3 高速WPAN
（三）无线城域网WMAN（无线宽带接入网）
（四）蜂窝移动通信网络（几G就是指第几代蜂窝网）
1 （重点）发展简史：1G（只提供话音服务）->2G（话音和短信，GSM（全球移动通信系统（Global System for Mobile Communications））开始出现）->2.5G（GPRS（通用分组无线业务（General Packet Radio Service）），该技术是234G的核心技术，该技术在2G中的应用标志着蜂窝网开始不局限于电话和短信，而开始数据业务）->3G（有三个无线接口国际标准，分别是电信使用的美国标准CDMA2000，联通使用的欧洲标准WCDMA，移动使用的中国标准TD-SCDMA，从3G开始蜂窝网以数据业务为主，并兼容2G，1G已淘汰）->4G（2013年12月4G登上历史舞台，其带宽达到1Gbps）->5G（2019年10月31号上线，下载一部影片只需几秒钟）。
2 以4G为例说明蜂窝网的组成结构：
首先，蜂窝网虽然放在了二层，但是它其实像分组交换网一样，是下三层的技术集合；
蜂窝的结构范围三部分：
（1）多台手机接入基站，每个基站是一个蜂窝（小区），基站作为AP；
（2）多个基站由一个无线网络控制器（RNC）负责，一个RNC所负责的就是一个无线接入网，RNC负责有线和无线的转换；
（3）多个RNC接入GPRS核心网，GPRS分为两部分，GPRS服务支持节点（SGSN）和网关GPRS支持节点（GGSN），SGSN负责话单产生、IP数据包转发、加密等功能，GGSN负责与互联网连接。
3 （重点）移动IP：
（1）背景（定义）：漫游：在一个BSA中移动或者在这个AP下线后再移动到另一个AP重新上网，这都不叫移动IP，移动IP指的是从一个AP移动到另一个AP无需用户手动上下线且IP地址保持不变（漫游），说白了就是移动IP技术让用户感觉不到自己换了BSS让端服务感知不到数据链路层的网络换了（进一步说就是换网了但是对于段服务而言IP地址不变）。
下面我们仔细讲解这个定义：
比如你连上了家里WiFi上网，然后你离开家到了公司，又连上了公司WiFi，这不叫移动IP，但是你在福建使用5G，然后你离开福建到了江苏，一样使用5G，这就是移动IP，前者你知道自己换了BSS，后者非专业用户根本不知道自己换了BSS，如果说福建和江苏离得太远非专业用户也能猜出换了BSS，不足以说明定义，那么，假设你现在在高速路上使用手机的导航服务，假设该区域的微博基站覆盖的范围大概在数千米，你开的速度是120，此时，一分钟内你就有可能变换BSS，驾驶员是感知不到BSS的变化的，这就叫移动IP；
除此以外，虽然在高速驾驶过程中，手机的BSS改变了但是导航服务并没有因此而中断，为什么呢？这就是移动IP技术的核心功能了：你离开家里的WiFi再连上公司的WiFi，中间经历了断网再连网的过程，断网后任何端服务都会中断，再连后那是重新连接，重新启动服务了，移动IP技术下的也会断网再连网，但是仅仅是数据链路层的BSS中断后再连，移动IP技术在网络层采用了一些技术使得网络层之上的端服务使用原来的IP地址依旧可以正常传输数据，因而导航服务并不会出现重新连接的情况。
（2）移动IP技术的原理：
根据对移动IP技术背景的了解，我们知道，网络层采用了一些方法对端服务屏蔽了BSS切换的细节，这些方法就是移动IP技术；
移动IP技术的核心是网络层技术（实际上在应用层实现，这和NAT一样，看上去是网络层技术实际上用到了运输层）；
通俗原理：毕业后联系同学的例子；
（重点）原理解析：
客户端最先在的网络叫归属网络，其网关叫归属代理，它最开始的IP地址叫归属地址（永久地址，这就是一直在说的不能变的地址），客户端现在移动到了另一个网络中，新网络叫被访网络（外地网络），其网关叫外地代理，客户端来到新网络后，向外地代理登记自己的MAC地址，外地代理会做两件事：a 为其分配一个本网络的IP地址，叫转交地址，b 通知归属代理客户端现在的转交地址；
当客户端向服务器通信时，虽然客户端IP由归属地址变成了转交地址，但是这并不影响数据包到达服务器，因为源IP并不重要；
当服务器向客户端通信时，服务器并不知道客户端的IP变了，还是向原IP地址（归属地址）发包，数据包一定会经过归属代理，归属代理拿到包后发现是发给已经离开的客户端的，于是再封装一层将其发给转交地址，外地代理拿到数据包后将包解封后按MAC地址发给客户端。
（3）关于转交地址：a 客户端发包时用，归属代理封包时用，外地代理为该地址做分配；b 转交地址不一定是唯一的，多个主机可以共用一个转交地址，这里有一个问题：虽然外地代理不ARP找目的客户端了，但是外地代理是怎么知道这个转交地址是哪个MAC的（这里假设没有跨越NAT）？
（4）三个协议：客户端向外地代理登记和注销，外地代理通知归属代理转交IP，归属代理->外地代理。
（5）同址转交地址：移动站和外地代理是同一台机器，这需要移动站上有外地代理应该有的协议功能。
（6）一种极端情况，客户端正好移动到了服务器所在的网络，这样服务器如果还按原来的流程转发就跑远路了，可以进行直接路由选择，即服务器上有一个通信者代理，向归属代理询问客户端的转交地址然后直接将数据给到外地代理而非归属代理。
四 无线网络对上层协议的影响
通过对无线网络的学习，我们知道无线网没有有线网通信质量好且在移动中切换BSS时可能会造成TCP报文段的丢包，对于TCP而言，如遇频繁丢包，TCP会以为网络出现拥塞，继而减少拥塞窗口（发送窗口的大小），降低发送速率，但是这显然是不应该的，针对此问题，有三种解决方式：
1 之前在基本概念的差错检测中我们讲过，Internet对链路层的可靠性传输采用了区别对待的态度，有线不用，无线用；
2 让TCP知道什么地方使用了无线，这个方法很扯淡，这是在破坏分层结构；
3 在有线和无线的分界点（往往是无线网的网关）上采用TCP代理转发。



第四章 网络层
一 基本概念
1 ATM是虚电路方式，它被分组交换网取代了。
2 物理层的设备：转发器（集线器、中继器）；数据链路层：网桥和交换机；网路层：路由器；网络层以上：网关。
二 网际协议IP
（一）IP协议的意义：
1 这是一个虚拟互连网络IP协议使得网络层对上层是虚拟的，即好像是一个网络，实际上是很多网络的互连；
2 明明MAC地址可以寻址，为什么需要IP地址？因为早期数据链路层并不是只有MAC地址，而且就算后面大家都用了MAC地址，但是局域网的类型也是有很多的，像什么有线的、无线的、他们的工作方式都不一样，所以IP协议的意义正在于使得上层对多样的数据链路层感到透明。
（二）（重点）IP地址：
1 分类的IP地址：D（1110）类是多播；
2 子网划分：子网掩码标识网络号（分类的网络号+子网号）；
3 CIDR：不说分类了，前缀就是子网掩码。
（三）（重点）IP协议（网络层或者说分组交换网）的工作原理：在第一章介绍分组交换网的时候已经足够说明，其采用存储转发的工作模式，收到一个包后先存在内存里，看看是直接交付还是间接交付，如果是间接，则进行路由选择，然后再转发出去。
1 路由表的条目：<目的网络地址，下一跳地址>，路由选择的目的就是为了选择一条最佳的条目。
2 流程：
a 根据IP数据报拿到目的IP地址，根据目的IP地址和子网掩码（注意：IP数据报中并没有子网掩码字段，子网掩码是看当前网络，分类虽然不说掩码，但是它的掩码显而易见，CIDR就是前缀）拿到网络地址；
b 先看看能不能直接交付，能就交付，不能就c；
c 看看有没有特定主机路由，有就交付，没有就d；
d 路由选择（CIDR是最长前缀匹配），如果没有路由，就e；
e 默认路由，如果未设置默认路由，就g；
g 丢弃。
3 在以上流程中，最核心的概念就是直接交付和间接交付，理解：只要你使用了IP地址，那么你就在使用IP协议，那么，你就得遵从分组交换网（IP协议、网络层）的工作原理也就是存储转发，也就是说你ssh一个局域网内的主机也是要存储转发的，只是说这个转发不进行路由选择，这叫不过路由器，进行了路由选择得转发即间接交付这叫过了路由器。
（三）IP数据报格式
1 首部长度字段和TCP一样也是4B为单位，也就是说IP的首部长度必须是4的倍数且最大为60B（选项字段最大40B）；
2 UDP只有全长，TCP只有首长，IP都有；
3 标识标志片偏移：
（1）因为IP数据报可能会超过MTU，所以用来分片和重组，但是分片会造成丢包率升高，因而运输层的TCP和应用层的UDP应该尽量避免让IP数据报超出MTU；
（2）（重点）通过标识字段区分IP数据报。
a 何为区分？
在运输层通过端口号来区分报文段或者用户数据报。
b 实际场景：两台主机A和B向NAT网关外的一台主机C发送ICMP报文，那么，A和B的源IP是一样的都是NAT对外IP，目的IP是C的IP，但是作为网络层协议的ICMP并没有端口号概念，C如何区分这两个icmp包？
c 标识字段可以区分ICMP报文。
4 生存时间（TTL，注意区分RTT）是为了避免IP数据报陷入环路：
（1）它的名字虽然叫时间，但是时间是早期概念，比如定一个时间，处理时间小于一秒就减一秒，但是现在的路由器处理速度已经很快了，因而TTL实际指的是跳数；
（2）路由器每次转发前减一；
（3）（重点）TTL占1B，因而最大条数是255，这里说明了如下事情：
a 世界上任何两台主机之间的路由器都不会超过255；
b 该字段一些协议比如IGMP，traceroute紧密相关；
（4）正常数据报的TTL=255，每路由一次减一，但是有一些IP数据报的TTL是特殊情况：
a 比如IGMP，TTL==1说明该数据报只在本局域网内传送；
b 比如traceroute的TTL是从1依次递增到255的。
5 协议字段：表示上层协议，即这个IP数据报该给谁，比如ICMP是1，IGMP是2，TCP是6，UDP是17，IP是4，ESP是50，即将IP数据报再封到一个IP数据包中。
6 首部检验和：注意是首部，TCP和UDP是全部，检验和也叫校验和，算法是，发送方把16位的检验和字段置0，把两个字两个字的相加，溢出就回卷（末位加1），将结果取反作为检验和，接收方也是两两相加（这就包括了检验和），算出的结果应该是1，如果不是则说明出错。
（四）IP的配套协议：
1 （重点）ARP：
（1）功能：根据IP地址得到MAC地址。这里引发了一个问题：ARP到底是哪一层的协议？实际上它是数据链路层协议，我们说哪一层是指功能，但是它确实使用了IP地址，就像作为网络层协议的NAT使用了端口号一样。
（2）工作原理：每个主机都存了一张ARP高速缓存表，用来记录局域网中<IP地址，MAC地址>这条映射，如果是刚通电或者换了网卡，那么主机A在通信时如果需要用到主机B的MAC地址，就会广播一条ARP请求报文（我是A的IP地址，我的MAC地址是，请问IP地址为B的IP地址的MAC是多少），然后B收到后就会回一条ARP响应报文（我是B的IP地址，我的MAC是）。
（3）注意：
a 如果B的表里没有A，B同时也会记录A的IP地址和MAC地址映射；
b 表中的记录不可能长期存在，因为主机可能会下线或者坏掉或者更换网卡，因而每条记录都有生存时间；
c ARP欺骗：一种利用ARP协议进行中间人攻击的方式，是后渗透阶段的常用手段，利用kali arpspoof工具实现攻击的步骤如下：
（a）在kali上开启IP转发：echo 1 > /proc/sys/net/ipv4/ip_forword。
注：事实上你可以不转发直接丢包，那就是dos攻击了。
什么是ARP欺骗？ARP欺骗说白了就是攻击机利用ARP协议（A要去B，就骗A我是B，攻击机发上一堆错误的ARP应答给A，正确的ARP应答是<B IP, B MAC>，攻击机发的是<B IP, KALI MAC>）让自己当上路由器了，所以它也可以冒充网关，但是要是在大型网络里敢这么干，攻击机的带宽如果不高，那就和dos没区别了。
（b）arpspoof -i 网卡 -t A B
注：
该命令执行后不要掐断哪怕您已经注意到A的arp表被成功修改，因为一断了就变回来了，实验亲测，不知为何；
如果不指定A，那么会对整个局域网进行ARP攻击。
（c）抓包，就可以抓到A到B的流量了，请用nc试一试吧。
2 ICMP：
（1）它是基于IP数据报的。
（2）类型：
a 询问（两个主要的：echo请求8和应答0，timestamp请求13和应答14）和差错报告（四个主要的：时间不可达3，时间超过11，参数问题12，改变路由5）。
b 所有的差错报告报文数据部分是IP头和IP载荷的前8个字节。
c 这六种主要的类型下，又有不同的代码，比如时间不可达，如果是端口不可达，那么代码值为3，如果是其他的，那么意味着包根本没有到达主机，nmap正式通过此方法探测UDP端口是否开放。
（3）ping（回送请求和响应）和traceroute（时间超过）：
traceroute的原理：执行traceroute命令的主机意在获取到达目的主机的路由序列，主机会TTL=1，TTL=2，TTL=3......TTL=255依次发送无法交付上层的UDP用户数据报，这样目的主机就会回复一个时间超过（11）的ICMP报文。
traceroute协议教给我们的小技巧：如果发现回复的ICMP报文的TTL=255，那么，说明这是第一条路由器。
（4）smurf攻击
攻击机向大量公网IP发送源地址为被攻击IP的ICMP echo请求报文。
3 IGMP：互联网组管理协议
（1）用于管理多播。
（2）为什么需要多播？比如一台服务器要向100个用户发送视频，如果采用单播，那么就需要发送100份，但是如果采用多播，只需要发送一份，路由器知道是多播报文在路由选择时会进行复制，到达目的主机所在局域网后，采用硬件多播。
（3）多播涉及两个层面的多播：一是网络层而是数据链路层，其中涉及地址映射。
（4）多播地址：
a D类地址作为多播地址；
b 多播地址只能用于目的地址而不能用于源地址；
c 一个D类地址标识一个多播组；
d 多播地址又分为：预留的多播地址全球范围内可使用的多播地址(224.0.1.0-238.255.255.255)，仅在本地有效的多播地址（239.0.0.0-239.255.255.255）。
（5）先会用，再说原理：一般使用UDP进行多播，接收程序除了正常的创建套接字、绑定本地地址以外，还需要setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)，mrep是struct ip_mreq，该结构如下：
struct ip_mreq {
    struct in_addr imr_multiaddr;   // 多播组的 IP 地址（多播组地址）
    struct in_addr imr_interface;   // 加入多播组的接口的 IP 地址（本地地址）
};
三 IPv6
（一）数据报格式：
1 流标号：感觉就像MPLS的标记，下一代路由器强调服务质量，同一流标号的数据报流是一个服务质量，对音视频数据有用。
2 相比IPv4，只有数据部分长度，因为它的首部长度固定是40B。
3 IP地址是16B，非常大，可以标识地球上的每一粒沙子，地址很长，使用十六进制表示，用冒号分隔，每一部分是两个字节，连续0可以省略一次。
（二）过渡：
1 双协议栈。
2 隧道技术即将IPv4数据报封装到IPv6中，这样IPv4的数据报首部的协议字段值是41。
四 路由选择协议
（一）概念：存储转发时，路由选择是其中的一个步骤，其目的是根据路由表查询下一跳地址，但是路由表中的条目从哪来呢？这就是路由选择协议的工作。
（二）Internet上充斥了各种网络，最大的是Internet，又分为国家或地区网，这种网往往是一个自治系统（AS），内部使用opsf（常用）或者rip，称为内部网关协议，国家与国家之间通过BGP（外部网关协议）互连。
五 NAT
在写代理时，是需要考虑NAT的。我们将在“TCP和UDP具体使用上的一些区别”这一部分详细探讨NAT。
六 MPLS（多协议标签交换）
（一）标签：MPLS就是虚电路，在分组交换网上建立一条”电路“，标签就是用来标记这个数据报属于哪条”电路“。
（二）多协议：标记后面可以是各种协议包而不一定是IP数据报。
（三）交换：使用专用的MPLS路由器，并且三层也是硬件实现。



第五章 传输层（运输层，对于搞Linux应用层（服务器）开发（这也是目前互联网行业的最核心的岗位）的程序员而言，掌握传输层尤为重要）
一 运输层最基本功能：区分进程（端口号机制）
1 网络层只能让数据包到达主机，但是这个包是哪个进程的呢？运输层提供了端口号机制：在一台主机上使用端口号唯一表示一个进程。
2 进程标识符不行，因为不同主机的操作系统可能不一样。
3 端口号的范围：0-65535。服务器使用0-49151，其中0-1023是熟知端口号，1024-49151是登记端口号，如果你决定上线一个使用该范围内的端口号的服务，需要向IANA登记（这个登记是国外的备案）；客户端使用49152-65535，是短暂端口号（服务器程序需要bind一个端口号，但是客户端不需要，由协议栈随即指定）。
二 TCP和UDP辨析
（一） TCP面向连接 - UDP无连接
1 概念辨析：
（1）TCP：
TCP连接的概念：一对一（dst_ip+dst_port : src_ip+src_port），一旦三次握手完成，标识该连接的套接字只能从dst接收数据到src，也只能从src发送数据到dst。
三次握手：
目的：建立连接即通信双方建立起收发缓冲区等资源并协调相关参数。
过程：
a 客户端往往在调用connect时率先发起第一次握手（SYN=1），表明自己希望与客户端建立连接；
b 服务器listen（listen是另一个线程）到SYN报文后建立相关资源，调用accept发起第二次握手（SYN=1，ACK=1）；
c 然后客户端的connect接收到第二次握手，发起第三次握手（ACK=1）连接建立完成（为什么需要第三次握手？与第四次挥手后的2MSL配合避免第一次握手的超时响应）。
三次握手存在的问题：黑客可以利用三次握手发起拒绝服务攻击（SYN flooding），即向服务器发送大量第一次握手，但是却不接收第二次握手，但是服务器往往会误认为这是一个正常的连接，于是准备了相关资源，随着大量无效的第一次握手的到来，服务器将不堪重负。
四次挥手：
目的：释放连接即通信双方释放收发缓冲区等资源
过程：
a 客户端应用进程调用close或者shutdown(sockfd, SHUT_WR)关闭发送缓冲区，TCP发送第一次挥手（FIN=1）；
b 服务器TCP收到第一次挥手后，通知应用进程（read==0）并发送对第一次挥手的ACK（第二次挥手），此时应用进程可以调用close或者shutdown(sockfd, SHUT_RD)；
c 服务器TCP发送第二次挥手后，应用进程和TCP可以发送完最后的数据，然后应用进程如果上面调用的shutdown而非close就调用shutdown(sockfd, SHUT_WR)发送第三次挥手（FIN=1）；
d 客户端TCP收到第三次挥手，响应ACK（第四次挥手），此时应用进程可以调用close或者shutdown(sockfd, SHUT_RD)；
之后，服务器TCP收到第四次挥手后就结束了，客户端发完第四次挥手后需要再等2MSL（最长报文段寿命，2min），这是担心第四次挥手丢掉以及与第三次握手配合避免第一次握手的超时响应。
另外，除了正常关闭，客户端也可能因为故障关闭，为了应对这种情况，服务器TCP每收到一次用户数据就重启一个保活计时器，时间通常是两个小时，两个小时后每75秒发送一次探测报文，如果连续发送10次客户端的TCP都没有响应那么就关闭这条连接。
（2）UDP：
UDP无连接：没有所谓“对”的概念，只有（src_ip+src_port），一个UDP套接字可以从src向任意ip+port发包，也可以接收任意ip+port的包到src。
（二）TCP可靠 - UDP不可靠
1 TCP：
（1） TCP可靠数据传输机制 = ARQ（= 超时重传 + 确认） + 滑动窗口协议
关于确认号:
Acknowledge Number indicates that "I have received all the data before the Number, and the Number is the starting number of the data I want to receive.". The calculation method is: the Sequence Number previously sent by the peer + the length of data sent by the peer.
（2） 如何避免发送方发的过快？
a 从边缘的角度，流量控制：
理想情况下，接收窗口（确认号+接收窗口大小）->发送窗口（发送窗口的起始位置即确认号+发送窗口大小即收到的接收窗口大小）；
考虑一种特殊情况：发送方被通告接收窗口为0后，将不再发送数据，而是等待接收窗口不为0的通告，但是如果通告包丢了，那就死锁了，为解决该问题，发送方在收到0通告包后要启动一个持续计时器，到期后主动向接收方发送一个1字节的数据以探测接收方的情况；
除了基本的流量控制方法以外，TCP还考虑了两种特殊情况（这种情况实际上都造成了“小数据包传输症”）：
（a）应用进程给的太慢，比如应用一次只发一个字节到TCP，这样如果TCP将一个一个的短字节封装后发到网络上势必造成网络效率的降低。
解决方法是：Nagle算法。
启动Nagle算法后，TCP最先会发小数据包，但是不会一直发，之后只有当以下情况，TCP才会发送数据：
收到ACK；
发送缓存中的数据量已经达到发送窗口的一半或达到MSS；
如果在指定的时间内（一般是200ms）没有收到确认，则发送。
Nagle算法虽然解决了小数据包传输病但是会造成延迟，对于时延敏感的应用而言，Nagle算法并不是必选的，可以通过setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag)来禁用Nagle算法。
（b）糊涂窗口综合征：应用进程收的太慢，比如TCP的接收缓冲区已经满了，但是应用进程只收一个字节，然后TCP向发送方通告了接收窗口为1，发送方就不得不发送小数据包。
解决方法是：接收方等待一段时间，当接受缓冲区的剩余空间达到一半或者可以存下MSS的时候再通告发送方。
b 从核心的角度，拥塞控制：
（a）概念：堵车，这里要理解两点：
加大带宽、路由器的CPU、内存等方法并不会真正解决拥塞，因为比如带宽大了，CPU和内存还是一样，反而会加大拥塞；
拥塞发生后会造成大量包重传，重传反而会加剧拥塞。
（b）拥塞窗口（cwnd） == 发送窗口（swnd），也就是说，发送窗口的大小可以由拥塞来决定，也可以由TCP报文段中的接收窗口（rwnd）字段来决定。
（c）TCP感知网络是否拥塞的依据：重传。
（d）一般算法：
慢启动：当一个 TCP发现有重传时，为了避免立即向网络发送大量数据而导致网络拥塞，TCP 会从一个很小的拥塞窗口开始，每收到一个确认就将拥塞窗口增大一个报文段的大小，直到达到慢启动阈值 (ssthresh)；
拥塞避免：当拥塞窗口达到慢启动阈值后，TCP 会进入拥塞避免阶段，在此阶段，TCP 每RTT只将拥塞窗口增加一个MSS，即线性增长，以避免网络拥塞；
快速重传：当 TCP 发送端连续收到 3 个相同的确认时，就认为出现了网络拥塞，会立即重传对应的报文段，而不必等待重传定时器超时；
快速恢复：在收到 3 个重复确认后，TCP 会将慢启动阈值设置为当前拥塞窗口的一半，并将拥塞窗口设置为慢启动阈值加上 3 个报文段的大小，然后进入拥塞避免阶段。
（e）AQM（主动队列管理）：
技术背景：我们知道路由器的工作原理是存储转发，其转发缓存是一个队列，按常理看，路由器的队列满了后再到来的IP数据报就得丢了（尾部丢弃策略），但是这么做，尤其是一些中心路由器，会丢掉相当一部分不同TCP连接的IP数据报，继而导致网络中相当一部分TCP启动拥塞控制，这样许多TCP几乎在同一时间进入了慢开始状态，网络的通信量突然下降，而网络恢复正常后通信量又会突然增多，显然这不是一个好的现象（TCP将该现象称为全局同步），为了避免全局同步现象，IETF在1998年提出AQM；
AQM：不等队列满了再丢包，而是在队列没满的时候就有选择性地丢包，让部分TCP进入慢启动状态而避免全局同步；
RED：IETF研制了一种叫RED（随即早期检测）的方法，即让路由器管理两个参数（队列长度最小门限i和最大门限a），设目前队列长度是x，若x < i，则接收新来的IP数据报，若x > a（这种情况不太容易发生），则丢弃，若i < x < a，以一定概率p随机丢弃一些IP数据报；
存在的问题：尽管IETF建议大家使用RED，但是经过实践证明，RED的表现并不好，这主要是因为丢弃概率p难以计算，路由器怎么知道哪个IP数据报所在的TCP连接是“好”还是“不好”呢？在2015年，RFC不再推荐使用RED，但是AQM是一个优秀的思路，最近人类也开发了一些新的AQM方法来替代RED，但都在实验中。
2 UDP：
没有任何可靠数据传输机制，也没有流量控制和拥塞控制，用户数据报出现任何错误直接丢掉，因而这也是我们为什么强调在使用UDP发送数据时要尽量避免网络层的分片和重组。
（三）TCP和UDP的收发缓冲区区别
1 结构（结构上的区别导致recv上存在区别）
（1）TCP：
a TCP收发缓冲区的逻辑结构是一个字节数组；
b 假如来了1w个字节，我们应用层先读5000B，然后再去读剩下的，是可以读到的；
c 所以，基于TCP的代理服务器在实现上非常简单，根本不需要关注用户的数据有多长，随便你读多少再转发出去就行了，你甚至可以只读一个字节；
d TCP的应用层接收数据后需要解决粘包。
（2）UDP：
a UDP收发缓冲区的逻辑结构是一个循环队列；
b 假如来了1w个字节，我们应用层先读5000B，然后再去读剩下的，是读不到的；
c 所以，UDP应用层在处理未知长度的数据转发时非常难受，我们根本不知道用户要发多长数据，自然就不知道该开辟多大缓冲区，开辟大了浪费内存，开辟小了代理失责，所以，应该怎么办呢？
d 而UDP不需要解决粘包。
2 大小（大小上的区别导致send上的区别）
（1）协议规定：TCP未规定 UDP 65507	不能调整
（2）收发缓冲区大小：TCP r128KBs16KB UDP r208KBs208KB	可调整
（3）应用层（在发送时，TCP和UDP有两点关于发送数据大小的区别：TCP无需分片，UDP需要分片；TCP无需考虑发送数据的多少，而UDP不能超过65507）：
a 作为一个应用层的程序员为什么需要考虑长度？因为MTU，其实不考虑也没关系，因为IP层会帮我们分片和重组，但是为了提升效率和降低丢包率，我们应该尽量避免让网络层去分片和重组。
b 根据上一点，UDP需要分片，但是TCP为什么不需要呢？因为TCP帮应用层程序员分了，TCP有一个MSS机制，在握手时，TCP会根据MSS设置对数据进行分片和重组，再交给IP层，也就是说TCP帮我们做了分片和重组，因而在使用TCP时，我们只需要确保自己发送的数据长度不超过socket的SNDBUF的长度就行了，如果超出，也可以用setsockopt去调。但是，对于UDP而言，并没有MSS，UDP直接把应用层给他的报文作为报文段去发送了，因而，为了避免分片，我们一般不让UDP应用层发送超过548B（Internet）或1472B（局域网）的数据，但是，在写代理时，我们可不知道用户会发送多大数据，因而此时代理就需要考虑是否进行分片和重组了，再次强调分片和重组不是一个必选项。
c 为什么TCP可以不用考虑发送数据的大小？因为人家是字节流啊，你就算是一次发一亿个字节，TCP无非就是写缓冲区一直处于满载状态但并不会丢掉你的包。
三 代理技术
（一）两大功能：
1 从一开始都是为了正向穿透内网而设计的，socks5开始支持反向TCP代理，ss开始加密；
2 隐藏源主机IP，基于此可以给网络攻击做防溯源。
（二）技术原理：
0 最重要的理解（从开发角度看）：代理说白了就是>=2条连接见复制粘贴数据（连接数量大于等于3则为代理链）：
（0）代理程序包括一个代理客户端和代理服务器，
（1）我们说起来代理就是指代理服务器，表现为一个网络服务（ip:port）。
（2）代理的数据转发流程（一切理解的根本）：
a 场景说明：一个http-client（192.168.43.223:1142） connect http://10.0.34.22:1032，假设有个socks5代理服务是:socks5://192.168.43.171:1141。
b 2条连接的数据转发流程（最基本）：
流程叙述：192.168.43.223:1142将它的HTTP数据本来是直接给TCP，但是现在192.168.43.223:1142必须自己写一个socks5协议的客户端并使用它，socks5代理客户端负责connect socks5代理服务（192.168.43.171:1141）并把http数据封装在socks5协议包发送给TCP，然后192.168.43.171:1141从TCP拿到数据后解包拿到HTTP数据，启动一个TCP客户端向http://10.0.34.22:1032发送，响应只需沿着TCP连接原路返回就行。
总结来看（很明显能看出来有两个tcp）：http客户端->自带的socks5代理客户端->tcp（socks5协议包）->socks5服务->tcp客户端->tcp（http协议包）->http服务。
第五个是tcp客户端（真假问题的一部分），而不是http客户端。你要明白：代理协议作为http与tcp之间的中间协议，http数据是用户数据，这里举例是http，其实不管是数据都是用户数据，socks5协议根本不应该知道我得用户数据原来是http协议包，如果协议这么写，一方面犯了网络协议开发的大忌：分层不清，另一方面侵犯用户隐私。
c 
提出问题（自带 or 不自带）：
上面的流程清楚的展现一个最基本的2条连接的数据转发流程，对于这种情况，但是不知道你有没有发现一个致命的问题：我们上面的例子中，192.168.43.223:1142需要一个socks5代理客户端程序，我们说这得192.168.43.223:1142自己去写，是的，这没毛病，有相当一部分程序都提供了socks5等各种代理协议的客户端，比如著名的curl、ncat等，但是，我们在生活中也确实见到了很多没有自带socks5代理客户端的网络应用客户程序，它们难道因为没有自带的socks5代理客户端就一辈子都不能走socks5代理了吗？
解决问题：
使用第三方工具的实例：没有socks5代理客户端程序的网络应用客户程序可以通过一些工具第三方工具使用socks5，比如谷歌浏览器使用SwitchOmega，比如Windows的各个客户程序都可以使用系统代理，比如proxychains4，那么，这其间的数据转发流程是什么？
proxychains4使用方法：就拿著名的proxychains4（它就相当于Linux下的系统代理）来说：第一步（告诉proxychains要走的代理服务）：vim /etc/proxychains4.conf，写入：socks5 192.168.43.171 1141；第二步（使用proxychains的代理客户端）：在192.168.43.223:1142启动命令的最前面写上proxychains。
流程总结（很明显能看出来有两个tcp）：http客户端->http客户端所在主机的prxoychains的socks5代理客户端->tcp（socks5协议包）->socks5服务->tcp客户端->tcp（http协议包）->http服务
d 
提出问题（2 or >2）：
上面谈到的两种代理场景（一种自写socks5代理客户端一种使用第三方代理客户端比如proxychains）都是两条连接的场景，那么，>2条连接呢？
解决问题：
场景说明（假设我们使用proxychains，注意这个例子是实际应用中极其广泛的例子比如ssh -R、ssh -D、ss、tor都是这么用的）：一个http-client（192.168.43.223:1142） connect http://10.0.34.22:1032，假设有个socks5代理服务是socks5://127.0.0.1:1001（也能是192.68.43.223，区别在于127只能给本机用，192能给其他主机用，我们这里就说127），192.68.43.223已经起了（这是需要提前配置，比如ssh -R、ssh -D、ss-local、tor等都是在做这个事）一个socks5代理客户端连接了connect来了另一个socks5代理socks5://192.168.43.171:1141，192.168.43.171起一台tcp客户端connect http://10.0.34.22:1032。
流程总结（很明显看出来是3个tcp）：http客户端->http客户端所在主机的prxoychains的socks5代理客户端->tcp（由于是本机，这里或许是域套接字，socks5协议包）->http客户端所在主机的socks5代理服务（就是127.0.0.1:1001）->真实socks5代理服务的socks5代理客户端->tcp（socks5协议包）->真实socks5代理->tcp客户端->tcp（http协议包）->http服务器
e 
提出问题（真 or 假）：
代理链技术的核心问题：上面谈及的第一层代理服务socks5://127.0.0.1:1001是一个真实的代理吗？（不是）
换言之：
socks5代理客户端到底是什么？（分第一个和后面（我们也叫后面叫链代理客户端））
proxychains这种代理客户端又到底是什么？（能第一个也能后面）
ss、ssh、tor等的代理客户端又到底是什么？（只能后面）
回答（触及代理的本质）：
不是真实代理，实际上这个代理服务是一个伪服务（假服务）或者叫映射服务（具体而言，1001是1141的映射端口）。
伪服务和真实服务的区别在哪？伪服务只转发socks5协议包而不解包，真实服务拿到socks5协议包解包得到用户数据使用一个tcp socket发送。
所有客户端汇总：第一个socks5代理客户端 + 链 + 最后一个tcp客户端
第一个socks5代理客户端是没有伪服务的，它直接从http客户端那里接收数据。
伪服务 + socks5代理客户端 == socks5链代理客户端。
最后一个客户端是tcp客户端而非socks5，这一点在a中已说明透彻。
f 
提出问题（正 or 反）：
上面我们说到的问题全是正向代理（== 全部是给客户端做代理），那么，如果我们想给服务器做代理（反向代理）呢？
解决问题（对比正反）：
区别1：先从最简单的”2连接“看起，正向情况是：客户端知道服务器的真实ip和port但是服务器却只知道代理服务的tcp客户端的ip和port（服务器会以为这正是客户端的真实ip和port），反向的情况是：比如著名的nginx就是反向代理服务器，浏览器只知道nginx的ip和port（浏览器会以为这就是真实的wen服务器的ip和port）但是真实的服务器是知道浏览器的真实ip和port的。
我们称上面这种现象叫：正向代理是给客户端做代理，反向代理是给服务器做代理。
区别2：正向代理和反向代理的应用场景：正向：正穿（翻墙、ssh -L、ssh -D等）、nat（解决ipv4地址稀缺和架构内网）、隐藏客户端真实IP；反向：反穿nat（ssh -R）、隐藏服务端真实IP。
——防溯源——
这里我要说代理技术在网络攻防中的应用了：
在信息收集、爆破、正向连接时，攻击者作为客户端，正向代理会起到隐藏攻击者IP的作用。
在反弹连接中，攻击者作为服务器，受害者作为客户端，可以给cc做反向代理，比如cdn、tor、ssh -R，也可以给target做正向代理，比如很多rat自带的pivot、socks5（ssh -D + proxychanis or shadowsocks，裸socks5是不行的）。
APT攻击的本质其实就是ssh -R（一条基于tcp的ssh连接 + 端口转发功能），如果你要自行开发APT，你可以使用其他协议比如https，专门的端口转发功能虽然可以不用开发（所谓的”专门的“就是说，你在cc上通过一条反向连接向比如/bin/bash发号施令，这也是端口转发啊，只是你把它内置（不需要connect直接数据复制）了，没有专门提供这个功能给别的client-server用）但是这个功能也是APT工具的基础功能之一。
溯源（查流量，一个标准的回连流量是：payload + 伪装协议头（https、ssh，顺序是：http + tls） + [代理协议头] + tcp + ip）的思路：如果走了代理，看代理协议的包头（这就是为什么不敢直接用socks5）；看ip层（ip层不可能加密，所以你应该明白，不可能真的防的了溯源的，代理不行、ipsec也不行、怎么都有暴露为明文的ip地址的，所以防溯源只能说尽量增加对方溯源的难度）。
关于防溯源的一些其他思考：，如果你在攻击走了代理，但是你的代理已经可以说明你的个人信息，那么这种代理又有什么意义呢？（尽量用国外的vps）
——防溯源——
区别3（触及本质）：
反向代理链是什么鬼？比如超级常用的ssh -R就是一条典型的”3连接“反向代理链。
显然对比正向代理链，一样存在伪服务和第一个socks5代理客户端 + 链 + 最后一个tcp客户端，唯一区别在于：正向的伪服务拿到数据粘贴给代理客户端，而反向的伪服务拿到数据粘贴给代理服务器，虽然都是一条tcp连接，但是connect方向是相反的。因而你可以这样理解正反代理：正向代理的用户协议连接方向和代理协议的连接方向相同，反向则相反。
区别4：正穿使用正向代理（可2可>2），反穿使用反向代理（只能>2（”2连接“你可以想一下，反向代理服务器放在网内客户端连不上它，放在网外它的tcp客户端连不上内网服务））
1 代理、隧道、端口转发、端口映射、穿透这五个概念是从不同角度看了同一个事情。
（1）代理：
a 通俗叫法，生活中见的最多的叫法。
b 代理是从应用角度看待该技术：
想想什么是代理，打官司时，我们会请律师，律师就是我们和法官交互的代理，我们与律师交互，律师与法官交互。
（2）隧道：
a 通俗叫法，这在日常工作中常叫。
b 隧道是也是从应用角度看待该技术：想想什么是隧道当你开车经过一个隧道时，别人看不见你在隧道里。
（3）端口转发：
a 这是标准叫法；作为一个网络安全的专业人员，你应该这么叫。
b 观察数据流程可知：数据总是从一个端口发送到另一个端口再发送到另一个端口。
（3）端口映射：
a 端口转发的另一叫法，虽然在工作中很少有人说这个词但是这是最明确的叫法。
b 在上面的场景中谁是映射端口？tcp客户端的端口是客户程序的映射端口，伪服务是下一个伪服务或真实服务的映射端口。
（4）穿透：从应用场景的角度看待代理技术。比如正向穿透指从内网到外网（可以2可以>2，比如翻墙、ssh -L、ssh -D等），反向穿透指从外网到内网（必须>2（”2连接“你可以想一下，反向代理服务器放在网内客户端连不上它，放在网外它的tcp客户端连不上内网服务），比如ssh -R）。
3 一些叫法问题：
（1）和IPSec进行区分：网络层的ipsec技术一样可以实现代理的两大功能；从广义上来说，代理技术应该包括IPsec但我们一般说的代理技术不包括IPsec而仅包括传输层上的；另外我们一般不叫IPsec为代理而叫它隧道。
（2）socks5代理就是说socks5协议，那么有的时候也会听说tcp代理、udp代理，这也是在说tcp协议、udp协议吗？不，这种叫法其实不严谨，应该叫基于tcp的代理、基于udp的代理，比如socks5代理就提供了基于tcp的代理，但是tcp这个协议我们知道它是字节流的，实际上完全可以不写任何上层协议直接转发字节流，我们一般称这种代理为tcp代理，但是”udp代理“这种不严谨的称谓还是别用了，但是我需要你知道：有些人他也许写了一些基于tcp、udp的简易代理程序又没有给他们的协议起名字于是便直呼为tcp代理、udp代理，这是可以理解的。
（3）socks5协议是使用了socks5协议封装用户数据，那么其他的代理协议也是同一道理，比如http协议即是使用http协议封装用户数据，用户数据可以是任何传输层往上的任何协议包比如http、https、socks5等等。
（三）一个长期困扰我的问题：全局代理或透明代理是怎么实现的？设置虚拟网卡吗？
四 TCP和UDP在具体使用上的区别
（一）连接：TCP就是点对点，不存在广播和多播，但是UDP可以广播和多播，这导致TCP在进行代理转发时不需要考虑NAT类型，而UDP需要考虑去，且导致二者在P2P程序上也有区别。
1 NAT协议详解：
（1）功能：该协议早已是网络层的核心协议，它起初是为了缓解ipv4不足而设计的，但是人们发现这个协议还可以保护内网安全即防止NAT网关外的主机主动访问内部主机，这导致黑客更依赖社工去安插reverse backdoor，reverse backdoor回连RAT后，NAT网关上便建立了映射，RAT继而可以通过这条连接反向远控backdoor。
（2）和ARP一样：按理说，位于应用层的程序员是不需要考虑网络层而只需要考虑传输层的，但是无奈的是，NAT这个网络层技术使用了传输层的端口号机制（端口映射），所以这导致在代理服务器（我们一般默认代理服务器是正向的，但是反向代理或者说打洞中是一定会考虑NAT类型的影响的）这种场景中需要应用层的程序员考虑NAT类型可能造成的影响。
（3）其次NAT有两种类型：
a Cone（对src_ip+src_port做映射，而不映射dst_ip+dst_port），Cone针对dst的回包有三种处理方式：
（a）Full Cone（不记录dst_ip+dst_port，对任意dst的回包来者不拒）；
（b）Address-Restricted Cone（，也叫Restricted Cone，记录dst_ip，只接收来自dst_ip的回包）；
（c）Port-Restricted Cone（记录dst_ip+dst_port，只接收来自这个dst_ip+dst_port的回包）。
b Symmetric（对src_ip+src_port+dst_ip+dst_port做映射），这种情况在处理dst的回包时和Port-Restricted Cone一样，但是它更加严格，它是最严格的NAT类型，对于Port-Restricted Cone而言，只要src_ip+src_port不变，那么，映射出来的public_ip+piblic_port是不变的，但是对于Symmetric而言，public_ip+public_port在不同的连接中也是可能变化的。
2 TCP和UDP关于代理技术的区别：
（1）最后为什么TCP根本不需要考虑NAT类型的影响而UDP需要考虑？根据以上对于NAT类型的认识，src在NAT网络中向公网中的dst发包，对端回包时如果使用src发送时的dst，那么这对于任何NAT类型都是受用的，但是问题是，对端回包时如果使用了不同的dst，那么，Full Cone是可以回包成功的，Address-Restricted就不一定了，如果对端只变了dst_port而没有改变dst_ip那么可以回包成功，如果都变了就不行了，Port-Restrcted和Symmetric将不再接收这个对端的回包。所以，TCP由于其是一对一的，对端根本不可能换dst，因而TCP根本无需考虑NAT类型的影响，但是对UDP，对端是可以随意换dst的。
（2）在UDP代理开发中，公网中的UDP为了避免NAT的影响，需要以同一个套接字进行收发（意思是UDP服务器的哪个套接字负责接收数据，那么在响应数据时也必须使用该套接字，而不能更换该套接字的绑定）。
3 TCP和UDP关于P2P的区别：
（1）但是，像上面的一般的UDP服务器或者UDP正向代理的开发场景中，我们可以通过编程手段避免NAT类型的影响，但是有一个场景很特殊，那就是P2P，P2P程序需要跟换dst，这可就会引发很多问题了：第一眼看上去UDP更适合P2P，TCP好像不适合，而且UDP好像只能适应Full Cone。
（2）但是，我确实看到了很多P2P程序实现了无差别的程序，比如区块链，它们是怎么做的呢？下面我们将详细讲解P2P打洞技术（也叫NAT打洞或NAT穿越（透））：
（3）NAT穿越的三种方法：一在NAT网关上配置映射（比如在virtualbox上配置或者运营商给你配置以实现内网服务），二vpn隧道，三打洞包括UDP打洞、TCP打洞（这种所谓的打洞和backdoor完全一个底层逻辑，就是我进不去那就请你先出来），我们着重要研究的方法就是打洞技术。
（4）打洞的最主要方法ICE协议（包括STUN（Session Traversal Utilities for NAT）和TURN（Traversal Using Relays around NAT））；
（5）UDP打洞：理解四种类型肯定是最关键的，请这么想：出去考虑锥形和对称型的区分，也就是看目标地址和端口换了没（一般源不会换），进来考虑四种类型，也就是看源换了没（全锥不关注，地址锥关注地址，对称和端口锥全关注.那么我们就会发现：
a 全锥和任意其他类型都可以互通；
b 锥形互通；
c 对称型和地址受限型可以互通（和之前的一样，进行端口探测就可了），对称型和端口受限型可以互通（生日进攻理论：每个人的生日可能是 365 天里的任何一天，每年有 365 天，如果要让至少有两人的生日相同的概率超过 50%，问这个班级最少需要多少人？事实是，我们只需要向460个端口发包就可以获得80%的概率打洞成功），对称型和对称型难以互通。
（6）TCP打洞：
（二）可靠性：
TCP用于对于可靠性高的场景，UDP用于要求难以容忍时延但允许少量丢包比如音视频开发中。
（三）收发缓冲区的区别，详见上面。

第六章 应用层
一 音视频（其实也可以是运输层的上子层）
（一）基本认识
1 音视频往往被称为多媒体信息，其中”边下载边播放而不存储“的音视频（现在都是这，已经几乎没人看电影先下再看了）成为流媒体。
2 多媒体信息有两个重要特点：
（1）信息量大；
（2）对时延和时延抖动（时延的变化量）有较高的要求。
3 为什么会存在播放时延？
因为多媒体信息发送时当然等时，但是分组在网络上传输后就会发生时间差异，因此接收端往往等分组数达到一定数量后再以恒定速率将这些分组进行还原和播放，这种方式就产生了播放时延，但是也是为了尽量消除时延抖动。
4 目前互联网提供的音视频服务有三种类型：
（1）流式存储音视频，边下载边播放，但是源文件是已经存储好的，比如在腾讯视频上看电影。
（2）流式实况音视频，发送方边录制边发送，接收端边下载边播放，比如在逼站上看直播。
（3）交互式音视频：如互联网电话或者视频会议。
5 媒体服务器又称为流式服务器。
6 流式存储可以使用TCP，但是流式实况和交互式音视频应该尽量使用UDP。
7 RTP（Real-time Transport Protocol）和RTSP（Real-Time Streaming Protocol）、RTCP（Real-Time Control Protocol）一起配合作为基于UDP的一个运输层子层为上层提供音视频服务。
（1）RTP是协议主体；
（2）RTSP负责控制信息的传输。比如拿元文件、播放、暂停、结束等；
（3）RTCP负责服务质量的监视和反馈、媒体间同步、多播组成员标志。
二 DNS（域名系统协议简称域名协议，不叫域名解析协议虽然我们经常这么叫，域名解析是域名系统中域名查询的过程）
（一）基本概念
1 DNS：Domain Name System。
2 作用：将容易记忆的域名（比如baidu.com）转为IP地址。
3 （重中之重）域名（domain name）和主机名（host name）的区别：
（1）广义没区别：
a 主机名就是标识一台计算机的IP地址继而标识这台计算机的给人看的名字，域名也是；
b 它们都能够使用DNS协议。
（2）狭义有区别：
狭义上看，域名一般特指映射为公网IP的主机名或者说域名，主机名一般特指映射为私网IP或者本地IP（127.0.1.1见的很多）的主机名或者说域名。
既然分公私网了，有如下区别：
a 域名是全网唯一的，不能重复如同它所表示的IP地址一样；主机名在私网唯一就行。
b 域名会进行DNS查询，主机名只在本地解析不进行DNS查询，主机名最多就是解析到本地域名服务器。
4 解析在计算机中的意思是：地址转换，DNS域名解析就是将域名解析为IP地址，ARP地址解析就是将IP地址解析为MAC地址。
5 web服务器虚拟主机和负载均衡的原理：域名和IP地址之间并非一对一映射关系，一个IP地址可以映射多个域名（换言之，不同域名可以被解析为同一IP地址，在这种情况下，一个域名代表一个虚拟主机，这就是web服务器配置中著名的虚拟主机概念），一个域名也可以被解析为不同IP地址（注意：不是解析成了好几个让客户端去选，而是它只能被解析为它可以被解析的IP地址中的某一个，这就是著名的CDN和负载均衡技术）。
6 （重中之重）记录（record，即映射）：我们一般称<domain name， ip address>（当然不一定是IP地址）为映射，也叫记录（record），尤其是在各大云厂商平台上，record这个名词经常见到。
7 记录值：域名被解析到的值，即映射的value。
8 主机记录：就是域名前缀，比如www。
9 TTL（存活时间）：通过域名解析得到的记录在本地缓存多长时间。 
10 注册和备案（在中国又叫ICP备案，ICP备案号就是域名的身份证号）：
（1）注册你得去找域名服务商。
（2）备案：在中国大陆网站上线时是需要备案的，但不是CA证书必要备案，是域名需要备案，因为你的域名解析记录会被配置到三大运营商的各个DNS服务器上，如果你是个非法网站，那三大运营商何必给你配置解析记录呢？备案是政策问题，得看地方政策，但是CA证书不管在哪个国家，只要你想支持TLS就肯定得搞。
（二）域名（狭义）结构
1 初步认识：www（三级域名）.baidu（二级域名）.com（顶级域名），有些时候，有人申请了个域名叫wywywy.fun，然后他搞了一个子域名，www.wywywy.fun，会这个域名叫二级域名，这只是叫法习惯而已不要在意。
2 域：指单个名字，也叫标号。
3 组成：
（1）每个标号由数字、字母、-组成；
（2）每个标识不超过63B，为了记忆方便，最好不超过12B；
（3）不区分大小写；
（4）全长不超过255B。
4 级别低的域名写在左边，级别高的域名写在右边。
5 （重中之重）各级域名由其上一级域名管理，根域名由ICANN（Internet Corporation for Assigned Names and Numbers， 不归ISOC管）管理。
6 顶级域名分为三大类：
（1）国家顶级域名nTLD，cn中国，us美国，uk英国。
（2）通用顶级域名gTLD，最先确定的有7个，com公司企业，net网络服务，org非营利性组织，int国际组织，edu美国大学，gov美国政府，mil美国军事部门。
（3）基础结构域名（infrastructure domain）：这种顶级域名只有一个，即arpa，用于反向域名解析，因此又称反向域名。
7 中国的顶级域名是cn，在此基础上，中国把二级域名划分为“类别域名”和“行政区域名”两类。
（1）类别域名：ac科研机构，com工商企业，edu教育机构，gov政府机构，mil国防机构，net网络服务机构，org非营利性组织。
（2）34个省级行政区，比如bj，js等。
（三）域名服务器（DNS服务器）
1 全球的域名服务器构成了一棵域名服务器树，根域名服务器->顶级域名服务器->权限（权威）域名服务器，以查询www.test.com为例，详细说明：
根域名服务器：存储顶级域名（.com）及其对应的顶级域名服务器的地址。
顶级域名服务器：存储与其顶级域名相关的二级域名（example.com）及其对应的权威域名服务器的地址。
权威域名服务器：存储具体的域名（www.example.com）及其对应的IP地址。
我们会发现：
（1）上级存下级；
（2）只有权威域名服务器才真正存储<domain name， ip address>。
2 根域名服务器只有13个IP地址，且分布躲在欧美，在欧美，平均三百多万人能分到一台根域名服务器，但是在东亚平均两千万人才能分到一台根域名服务器，再次强调根域名服务器由ICANN管理。
3 权威域名服务器本身也是分等级的，比如x.y.z和q.x.y.z，一个权威域名服务器所管理的网络范围称为区，区是域的子集。
4 本地域名服务器（默认域名服务器）
（1）这种服务器不属于域名服务器的层级结构；
（2）这种服务器可以由网络工程师根据用户需求在局域网内搭建；
（3）它一般用于缓存局域网内常用的映射以避免总是向DNS系统查询以及做局域网内主机的DNS查询请求代理；
（4）一般会有两台，一台主域名服务器，一台辅助域名服务器。
（5）现代的TCP/IP协议栈一般都会自带一台DNS服务器作为一台本地域名服务器（127.0.0.53#53），这也是主机的DNS缓存。
5 再次说明和补充一些关于DNS服务器的最重要问题：
a 整个DNS服务器的结构分为了：树和本地（就像中国的政治体制一样，树是从乡镇开始的中共体制，本地是农村自治）。
b DNS服务器由谁管理：除了13个根域名服务器由ICANN管理以外，顶级DNS服务器和权威DNS服务器由各国或地区ISP（在中国就是三大运营商）管理，本地DNS服务器由政府、企业、校园等单位自行建设。
c 本地DNS服务器很重要，它是单位网的主机们进行域名解析的跳板，甭管什么解析类型，都得先到本地DNS服务器，这也是它为什么叫默认DNS服务器。
d 在小型局域网（家庭网络、手机热点等）中，网关路由器一般兼职DNS服务器，这一点对DNS spoof很重要。
（四）域名解析（域名查询）
（最重要的点到了，这里涉及DNS欺骗技术）
0 配置域名解析：
在说明域名解析之前我要先说明一件事情也是域名解析的前提，即域名解析就是查记录去了，但是前提是DNS服务器上有这条记录啊，如果没有，那么肯定是查不到的，所以，域名解析的前提是“配置域名解析”；
所谓的配置域名解析即是去本地DNS服务器添加记录，去hosts文件添加记录（Windows的在C:\Windows\System32\drivers\etc），去DNS服务器添加记录；
但是问题是，本地DNS服务器和hosts文件这是在系统管理员的管控范围内的，去DNS服务器添加记录无非就是两个手段：一是你在哪个域名提供商那里购买了域名，让该域名提供商帮你添加记录，或者你也可以干脆找ISP，二是你可以攻破DNS服务器。
再基于（三）中最重要问题对于本地DNS服务器的论述（c、d），我们可以得出DNS spoof的思路：
第一步：利用ARP欺骗冒充网关（一般在局域网里，网关就是本地DNS服务器，但是请注意：我们的原则是谁是本地DNS服务器我们就arpspoof谁）；
第二步：dnsspoof -i 网卡 -f 一个包含“<攻击者IP, 被攻击域名>”的文件
注：该命令相当于起了一台伪造的本地DNS服务器；
第三步：当局域网内的主机访问被攻击域名时，将会来到攻击者的web服务器，攻击者可以放个钓鱼网站什么的窃取信息或者挂马等。
1 （重中之重）顺序：本地DNS缓存->hosts文件->DNS查询
2 DNS查询：
（1）迭代查询：向本地域名服务器查询，如果没有，由本地域名服务器向根域名服务器查询，根据从根那拿到的结果向顶级查询，根据从顶级那拿到的结果向权威查询，如果没有，那就下一个，如果都没有，那就是没有；
（2）递归查询：向本地域名服务器查询，如果没有，由本地域名服务器向根域名服务器查询，再由根向顶级查询，再由顶级向权威查询，如果没有，那这个权威就接着向其他权威查询，如果都没有，那就是没有。
3 查询也不是非从根开始，如果本地已经有顶级了，那就直接从顶级查起，其它同理。
（五）记录类型（什么是记录？就是映射，很多时候也叫解析记录或查询记录）
1 A 记录(Address record)：将域名映射到 IPv4 地址。（最基本的信息）
2 AAAA 记录(IPv6 Address record)：将域名映射到 IPv6 地址。
3 CNAME 记录(Canonical Name record)：将域名映射到另一个域名。（重要，用于CDN）
4 MX 记录(Mail Exchanger record)：指定接收该域名邮件的服务器。（这也很重要尤其在渗透测试中，一旦黑客可以爆出企业的邮箱服务器，那么就可以攻击它了）
5 NS 记录(Name Server record)：指定管理该域名的 DNS 服务器。（渗透测试信息收集阶段的重要信息，如果有区域传输（这个事本来是网络管理员为了冗余备份而多高了几台DNS服务器并允许DNS服务器之间进行复制）就可以对爆出来的域名解析服务器的记录信息进行全盘复制）
6 PTR 记录(Pointer record)：将 IP 地址反向映射到域名。
7 TXT 记录(Text record)：包含任意文本信息,常用于验证域名所有权。
8 SRV 记录(Service record)：指定特定服务的主机和端口。（渗透测试常用，如果能爆出来这个，减轻了端口扫描的负担）
9 CAA 记录(Certification Authority Authorization)是一种特殊的 DNS 记录，它用于指定哪些 CA（Certificate Authority）有权为该域名颁发 SSL/TLS 证书。
（六）主机记录（域名前缀）
1 www：子域名的老大，一般和主域名一致。
2 @：就是主域名，没有前缀
3 *：泛解析，任何前缀
（1）泛域名解析（这是一种特殊的主机记录）：比如，如果京东开启了泛域名解析，那么你访问*.jd.com（*也不指代那些专门的，而是没有被配置的，比如search.jd.com这个域名配置了域名解析记录。那么人家肯定不参与泛域名解析），都将访问到一个IP地址提供的网络服务。
（2）泛域名解析走不了CDN。
4 mail
5 m：手机
6 自定义
三 HTTP（如不强调，则默认HTTP1.1）
（一）基本概念：
1 发展历程：HTTP0.9（90年代初诞生）、1.0（1996年）、1.1（1997年，曾经的霸主）、2（2015年，当前的主流版本）、3（2020年）。
（1）HTTP0.9：仅用于GET HTML页面。
（2）HTTP1.0：
a 虽然这时间已经有长连接（一次TCP连接可以发送多次请求）了，但是默认短连接（一次TCP连接一次请求响应）即Connection字段值默认为close；
b 队头阻塞问题：就算长连接，请求响应的过程也是停等协议，前面过不来后面就过不来。
（3）HTTP1.1：
a 这个版本才算是真正的HTTP协议了，而且这也是霸占web最长时间的版本；
b 长连接即Connection字段值默认为keep-alive；
c 队头阻塞问题：引入管线化，浏览器可以不用等到响应再发下一个请求，但是依旧存在TCP层面的队头阻塞问题；
插：到目前为止，HTTP协议存在的主要问题就是：如何长连接、如何多路复用（管线化，解决队头阻塞问题）、如何压缩头部且避免头部的重复发送、如何让服务器也能主动推动消息（server push）。
（4）HTTP2：针对以上问题进行了解决但是也没有解决的很好，引入websocket、压缩头部是HTTP2的两点，另外还有我们强调的长连接和多路复用，另外还有TLS义务化、协商、流量控制等。
插：事实上HTTP在发展过程中一直在追求如何提升协议效率？这也是协议发展的最核心问题，被谷歌称为speedy问题（SPDY），不光是以上谈到的种种技术，像Ajax这种技术也是为了提升效率而出现的。
（5）HTTP3：HTTP3基于QUIC协议，QUIC是基于UDP的可靠数据传输协议，之前都是基于TCP，因此该版本有望彻底解决队头阻塞问题。
2 URL（统一资源定位符是URI统一资源表示的子集，用来指示资源的位置，URI很多时候也叫路径或者路由）：这个格式不光用于HTTP，用于任何协议比如ssh、ftp、mail等各种应用层协议，主要是?（查询字符串：keyvlaue形式，多个以&相隔）和#（子资源：比如某个文档中的某个部分）；
3 web服务器管理协议WebDAV：这就相当于phpadmin对MySQL的意义了，一旦被破解即宣告黑客攻破web后端。
4 HTTP协议的最大特点：无状态，即一次请求对应一次响应，每次请求响应间没有关系（web服务器不记录这种关系），因而基于HTTP的APP必须考虑如何进行状态记录和会话管理。
5 HTTPS一般是客户端验证服务器即服务器把证书给客户端（这叫服务器端开启了证书验证），让服务器去验证客户端这个不太现实因为证书是要花钱的，服务器就那一台两台而且属于企业，但是客户端可是成千上万台且属于用户，这个成本很大也没有用户愿意付这个成本，就算是自签证书也没有多少客户愿意搞，久而久之就形成了这样一个现状。
（二）HTTP协议概览（说行不说头，头见下一个）
1 HTTP的基本通信规则（B/S架构，理解这一点就理解了web开发的根本，就理解了AJAX的道理）：browser发请求守响应，web server收请求发响应；
2 包格式：
（1）请求包格式：
请求行：方法 URI 协议版本
注：如果是GET方法，那么没有请求体，用户的请求数据在URI里。
请求头：一行一个key:value
请求头按顺序分为请求首部、通用首部、实体首部
空行
请求体
注：URI可以是URL也可以子路径。
（2）响应包格式：
响应行：协议版本 状态码 状态码的原因短语
响应头：一行一个key:value
响应头按顺序分为响应首部、通用首部、实体首部
空行
响应体
3 请求方法（8种）：GET（下载资源）、POST（传输请求体）、PUT（上传资源）、HEAD（只请求响应报文首部）、DELETE（删除资源）、OPTIONS（查询要请求的资源所支持的方法）、TRACE（如果走了代理就告诉浏览器，很不常用，太危险了容易引发跨站追踪攻击）、CONNECT（隧道）。
（0）说明：GET和POST是最主要的两个方法，因为它们就是请求本身，而不是某个具体的功能，也就是说，我们要清楚：GET方法并不是和PUT方法呼应的下载资源的方法或者说下载资源只是它的一个子功能（RAT里的get和put一般都相呼应，所以在这看见了GET和PUT就容易以为它们相呼应），准确的说GET是用来发送请求的，HTTP客户端本来就是要发送请求啊，所以这是一个宽的概念而不是具体的某个功能。
（1）GET方法：
用途：主要用于查询数据、获取数据、页面跳转等。
安全性：相对较差，因为所有的数据都显示在URL中，如有敏感信息可能会被别人看见。
数据长度限制：请求行的第二个字段URI一般最长2048B。
幂等性：GET请求是幂等的，即多次请求同一个资源的结果是相同的。
（2）POST方法：
用途：主要用于提交数据，如表单数据或者上传文件。
安全性：相对较好，因为数据在请求体中，不会显示在URL中，适合传输敏感信息，虽然但是也仅仅是被容易被眼尖的人看见，要使用TLS，二者没有区别。
数据长度限制：取决于前后端的输入输出缓冲区的设计。回忆一下底层（TCP的收发缓冲区的大小一般是发16K收128K，而TCP的协议并没有限制包大小，TCP有MSS机制，TCP由于字节流所以其缓冲区大小不影响上层），根据回忆，web程序员和web服务器的程序都不需要照顾MTU，因而在设计缓冲区大小时，位于会话层的浏览器和服务器的缓冲区一般都挺大的，但前后端的缓冲区大小一般会因具体情况设计，根据我的生活经验，web程序员往往不会搞那么大，我们在很多地方都可以看到字数限制，尤其是用户名密码等输入框对字数更是有严格限制，因为这里涉及缓冲区溢出的安全问题。
幂等性：POST请求不是严格幂等的，即多次请求可能会有不同的结果，比如多次提交订单会创建多个订单。
（3）FORM一般用POST但是也能用GET。
4 URI：/对应服务器上的root。
5 状态码：告知请求结果：
1xx：Informational，请求正在处理；
2xx：Success，请求被正常处理；
200：OK
204：No Content
206：Partial Content
3xx：Redirection，重定向（说白了就是要求浏览器再次请求）；
301：Moved Permanetly
302：Found，临时性重定向，禁止POST在再次请求变换为GET
303：See Other，和302一样，但是明确表示浏览器应该采用GET方法获取资源
304：Not Modified，资源已找到，但不符合请求条件
307：Temporary Redirect，和302一样，但不会将POST变成GET
4xx：Client Error，无法处理请求；
400：Bad Request，请求语法有问题
401：Unauthorized，要求用户进行认证（首次请求）或者认证失败
403：Forbbiden，不允许访问该资源。这个理解很重要：这意味着服务器理解了请求，但拒绝提供资源，通常是因为权限设置或访问限制。
404：Not Found，没有该资源，说明URI错了
444：
当Nginx服务器收到一个请求，但决定不向客户端发送任何响应时，可以使用状态码444。
444状态码通常用于阻止恶意请求或者无效请求的响应。它表明服务器在收到请求后，会立即关闭连接，而不是按照HTTP协议的标准方式进行响应。
5xx：Server Error，处理请求出错。
500：Internal Server Error，web服务器bug
502：Bad Gateway，服务器没开。
503：Service Unavailable，被DDoS了
（三）HTTP首部字段
1 请求首部：
referrer：该客户的原始请求URI，后面不管怎么跳原始URI只有一个，服务器可根据该值统计源站信息以防止CSRF攻击。
2 响应首部：
location：通知浏览器跳转到哪。
3 cookie相关字段：
（1）请求首部：cookie，响应首部：set-cookie。
a cookie的概念：服务器放在客户端的数据。
b cookie的工作原理（整个流程、字段值、思路）：
浏览器首次请求服务器时，
服务器会要求用户输入账号密码等用于认证的信息（认证信息），
服务器对认证信息进行认证，认证通过后生成一个SESSIONID（具体到Java EE的是JSESSIONID，PHP的是PSESSIONID）及相关信息（expires（有效期，不指定则是会话cookie即浏览器关闭则失效）、path（cookie适用于哪些URI）、domain（cookie适用于哪些域名，domain和path一起决定了该cookie适用的范围）、secure（限制浏览器仅在使用HTTPS时才发送cookie）、HttpOnly（限制JavaScript对cookie的获取，避免XSS攻击，事实上初衷并不是为了解决XSS）），
SESSIONID和相关信息会作为set-cookie字段的value响应给浏览器，
浏览器用户再次访问相关网页时不用再登录了因为请求包会携带value为set-cookie的value的cookie字段，
服务器程序会根据cookie中携带的SESSIONID信息（key）和其他信息去redis上查（当然也会做其他检测比如检查过期了没），有说明曾经登过（注意这里就是认证了）。
c cookie的作用：通过对cookie的工作原理分析可见：
第一点：cookie可用于解决HTTP协议无状态的问题。
第二点：事实上可以让cookie记录更多信息比如用户的购物车信息以实现对用户的个性化推送。
第三点：在会话管理上解决了单点登录这个认证问题。
d 注意：cookie是合法的，想要让服务器记录客户端的状态只能用cookie，这没办法。
e cookie的缺点：cookie着重在于解决了无状态的问题而不是认证问题，也许cookie的初衷确实是为了解决认证问题，但是它解决的并不好（会造成cookie复用）：
（a）由于服务器需要存储cookie信息，因此当网站压力很大时这对redis而言是个考验；
（b）cookie不能跨域共享，这对分布式系统而言并不友好。
（2）JWT（Json Web Token，很多时候简称Token）正是为了解决以上缺点产生的。
a 优点：更好的解决了无状态，但是复用问题依然没有解决：
（a）不用存任何信息；
（b）能跨域；
注：归根到底都是验签导致的。（这是最重要的一点，原因请见”网络安全章节的认证技术“）
b JWT的组成：
（a）header：一个json对象，保存元数据（签名算法和类型）。
{
  "alg": "HS256",
  "typ": "JWT"
}
（b）payload：一个json对象，保存实际数据，可以是官方定义的，也可以是自定义的（更好的可扩展性）：
官方定义的：
iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
（c）签名：使用选定算法对前两部分签名。
c JWT一般放在请求头的Authorization: Bearer 这里，响应中放在哪取决于具体设计。
4 websocket
HTTP首部中与WebSocket有关的字段是：
（1）Upgrade: 当客户端希望升级协议时，通过该字段通知服务器，其值为"websocket"。
（2）Connection: 指示连接的类型。在升级到WebSocket时，其值为"Upgrade"，表示将协议从HTTP升级到WebSocket。
5 MIME：起初被用于邮件，现如今已发展称在应用层被广泛使用的数据类型表示法，作用是表示应用层数据的类型，也是HTTP协议的标准数据类型表示法。
（0）基本问题：
a 对应了后端的mutipart方法。
b 对应了前端的Content-Type字段，除了下面这些值以外还可以带charset-UTF-8，比如：Content-Type: application/json; charset-UTF-8，这是很常见的。
（1）文本格式:
text/plain: 普通文本
text/html: HTML 文档：响应包默认的格式。
text/css: CSS 样式表
text/javascript: JavaScript 脚本
（2）图像格式:
image/jpeg: JPEG 图像
image/png: PNG 图像
image/gif: GIF 图像
image/svg+xml: SVG 矢量图像
（3）音频格式:
audio/mpeg: MP3 音频
audio/wav: WAV 音频
audio/ogg: Ogg Vorbis 音频
（4）视频格式:
video/mp4: MP4 视频
video/webm: WebM 视频
video/ogg: Ogg Theora 视频
（5）应用程序格式:
application/x-www-form-urlencoded：这是POST采用的默认格式（GET不需要Content-Type这个字段），表明HTTP包体的数据格式是form格式即key=value&key1=value1......。
application/json: JSON 数据
application/pdf: PDF 文档
application/zip: ZIP 压缩包
application/octet-stream: 二进制数据
（三）web应用程序（webapp）基本概念（我们将另开文档讨论HTML、CSS、JS、servlet、Java EE等webapp开发的技术）
0 webapp的基本概念：webapp强调的是http往上会话层、表示层和应用层的概念。
1 前端（浏览器的上层技术）：负责解析并渲染HTTP报文的主体，一般是HTML文档，有三个主要技术：
（1）HTML：超文本标记语言，标记了你用眼睛看到的页面的任何东西的位置、类型等；
（2）CSS：样式表，你看到的东西的形式，多大多小、多长多宽、怎么转怎么扭、什么颜色等等；
（3）JavaScript：浏览器脚本语言，用来操作浏览器上的任何HTML和CSS，通过DOM（文档对象模型，可以解析HTML、XML等标记语言）解析器进行操作。
2 后端（web服务器上面的APP，很多时候也叫web服务，web服务器其是web服务的容器）：处理从web服务器拿到的请求并送给服务器，处理的过程涉及各种数据结构和算法、与数据库的交互、甚至复杂的分布式处理。
（0）基本概念（以nginx为例）：
a web服务：ip:port这代表了一个web服务。
b 虚拟主机：同一IP可以承载不同域名就是域名。
顺便说一下旁站（同服站点）：同一服务器上的不同站点，只要域名和端口号唯一标识了一个站点，只要这两个因素有一个不一样那就是不一样的站点。说白了是一个server对于一个站点。如果域名和端口号都一样那只能唐诡目录来区分。
c 负载均衡：同一域名可以被解析为不同IP。
d 分支功能：比如你访问https://www.wy.com/emp和访问https://www.wy.com/fg，你会发现路径不一样，这便是一个webapp的分支功能。
（1）APP要从web服务器拿数据送数据，这里需要一个接口程序，我们一般叫这个接口程序为CGI（通用网关接口），比如servlet就是，servlet是为Java应用程序设计的CGI，被广泛应用于各类Java EE框架中。
（3）这里明确几个概念：容器 == web服务器，中间件 == 框架（servlet作为接口其实能叫中间件也能叫容器一般认为是中间件，因为一般你拿到的servlet也是被封装过的，servlet作为框架的基础）。
3 XML：
（0）基本概念
a 可扩展标记语言。
b 广泛作为web应用的数据交换格式（这是应用层的格式，因而web程序员是要做处理的）和配置文档格式（在Linux系统的/etc目录下我们会见到很多配置文档，其格式一般都不是XML，而是特定的或者INI（就是简单的一行一个keyvalue））。
c XML是web应用层的概念，虽然七层协议规定了表示层处理数据交换格式但是这是理论上来讲，实际上有的数据交换格式在表示层有的在会话层有的在应用层，比如form就是在表示层处理的，而XML和JSON是在应用层，这个不需要在意，需要在意的是web程序员往往需要函数一组encode和decode函数对其进行处理（在说JSON时我们会详细说明各个语言的关于JSON的编解码函数）。
（1）基本语法：
<book id="123" published="1925">
  <title>The Great Gatsby</title>
  <author>F. Scott Fitzgerald</author>
</book>
以上涵盖了开始标签、结束标签、属性、文本。
（2）注释：
<!-- This is a comment -->
（3）不被视作XML文本的文本：
<![CDATA[	开始
]]>	结束
（4）特殊指令：
<?xml version="1.0" encoding="UTF-8"?>
（5）实体引用（特殊字符，以&开头以;结尾）：
&lt; : <
&gt; : >
&amp; : &
&apos; : '
&quot; : "
4 JSON
（1）定义：比XML更轻量的数据交换格式和配置文档格式。
注：
a 我们一直说格式，说XML是格式，说JSON是格式，那么这个格式本质上到底是什么？或者问这是什么的格式？答案是就是一个字符串，就是一个字符串，就是一个字符串。不管是数据交换还是配置文档，那都是一个字符串。
b 我们谈到JSON就是在说JSON字符串而非JSON对象，这一点是理解JSON的关键，不说后面，就说JSON名字里就带了notation，notation本就是格式的意思（实际上在计算机学科中说起格式一般就是指字符串的格式啊），因而，JSON == JSON字符串 == JSON格式
（2）语法：
a 最外面也是最大的{}就是一个对象，里面是key:value形式，key:value与key:value之间是”,“，最后一个key:value不用写,了；
b 核心语法：key必须是字符串类型value随便。
举例：
{
  "string": "Hello, JSON!",
  "number": 42.195,
  "integer": 1234,
  "boolean": true,
  "null": null,
  "object": {
    "name": "John Doe",
    "age": 30,
    "email": "john.doe@example.com"
  },
  "array": [
    4321,
    "banana",
    true
  ],
  "nested_object": {
    "address": {
      "street": "123 Main St",
      "city": "Anytown",
      "state": "CA",
      "zip": 12345
    },
    "hobbies": [
      "reading",
      "swimming",
      "hiking"
    ]
  }
}
（3）JSON的全称是JavaScript Object Notation，为什么这种被各大语言广泛应用的字符串格式叫这个名字？因为这种格式的字符串最早是由JavaScript定义的，注意是这种字符串而不是这种对象，JSON对象说白了就是哈希表或者说字典啊，但是JavaScript把这种对象叫JavaScript对象并首次提供了parse和stringify方法用于JSON对象和JSON之间的解析并被广泛应用，这便是JSON这种格式的字符串为什么被叫JavaScript Object Notation的原因。
（4）在配置文档中，除了对象{}以外的五种基本数据类型：字符串（使用""，不能用单引）、数字（整型、浮点型）、数组（[任意类型, 任意类型, ...]）、布尔（true false）、空值（null）。
（5）在数据交换中，JSON允许的数据类型因语言而异。
（6）JSON对象到底是什么？在JavaScript中就是JSON对象，在CPP中可以引入JSON库，PHP中有关联数组，python有map类型。
（7）这是最关键的点：JSON对象和JSON的区别（除了我们一直强调的一种是对象一种是字符串）：其区别在于JSON对象是存储概念，JSON是通信概念，JSON对象需要序列化为JSON才能放到网络上通信。
（8）主要语言的JSON字符串和JSON对象之间的转化方法：
		str->obj		obj->str
JavaScript	JSON.parse	JSON.stringify
python		json.loads		json.dumps
php		json_decode	json_encode
（9）哈希表、字典、JSON对象的概念解析：哈希表 == JSON对象 == 字典
（10）哈希表的哈希和哈希算法的哈希是一个概念吗？在”网络安全密码学基础的完整性“中我们介绍了哈希的概念，因而你会发现这就是一个概念，在哈希表里也存在哈希碰撞，区别在于我们在密码学里谈及的哈希函数和哈希表用的哈希函数不一样。
5 URL编码：为了避免用户数据出现=、&等关键字，有一款网安常用的编解码工具CaptfEncoder，很不错。
（11）其次关键，要注意区分JSON和form：
a JSON和form虽然都是kv型但是在HTTP里他们是不同的数据格式，但是JSON是application/json，form是application/x-www-form-urlencoded；
b 另外，form格式是在浏览器和服务器层即表示层进行编解码而不是应用层，所以不管什么语言都不需要关注，但是JSON是应用层数据格式因而不同语言交互时需要去转换它。
6 前后端分离：
（1）前后端不分离的项目就是比如php里既写前端也写后端，这个页面往往以静态资源也有动态资源，用户请求php，静态的不动、动态的去处理然后再变成静态，最终以HTML响应给浏览器.
（2）前后端分离也是静态动态的分离，用户请求动态资源时，后端根据请求把数据给到前端。
（3）区别：其实就是AJAX这种技术，不要请求页面（页面中有静有动）而是请求静就请求静，请求动时再请求动，请求动拿到的是数据，往往是JSON数据。
7 XPath（可用于表达XML和HTML）：
（1）XPath 表达式的基本组成
节点选择:
/：选择根节点。例如，/root 选择文档的根节点 <root>。
//：选择文档中匹配指定路径的所有节点。例如，//element 选择文档中所有 <element> 节点。
路径导航:
.：当前节点。
..：当前节点的父节点。
node()：选择所有节点（元素、文本、注释等）。
谓词（条件）:
[]：用于在路径中添加条件。例如，/root/element[1] 选择 <root> 节点下的第一个 <element> 节点。
[@attribute='value']：用于选择具有特定属性值的节点。例如，//item[@id='123'] 选择 <item> 节点，其 id 属性值为 123。
运算符:
@：选择节点的属性。例如，/root/element/@attribute 选择 <element> 节点的 attribute 属性。
text()：选择节点的文本内容。例如，/root/element/text() 选择 <element> 节点的文本内容。
四 ssh
1 这个协议关键是理解shell是什么，这个在《Linux》的《根本理解》一文中有详细解释。
2 另外关于ssh的各种操作，配置文件、私钥登录、隧道等操作详见《Linux》的《ssh》一文。
五 邮件
（一）邮件是一种CS结构的应用层协议，为什么要强调这句废话？因为我在使用set发钓鱼邮件时还真没有反应过来邮件不能用mail、mutt或者python脚本等邮件客户端直接发到另一个用户的谷歌、微软或腾讯邮箱里。
（二）那么怎样才能发到某个用户的谷歌、微软或腾讯邮箱里呢？
1 方法一（但是，请注意：事实上，很多类似于mail的客户端都依赖于MTA（Mail Transport Agent））：
使用谷歌、微软或腾讯的邮箱客户端，
如果使用原有的客户端那就是我们日常发邮件的方法了，
如果使用mailsend、mail（mailx）、mutt、python脚本等方式发送也是可以的，你需要写明邮箱账号、密码、主题、内容、目标账户等信息。
2 方法二：
使用邮件传输代理，
smtp协议同时也定义了邮件服务器如何发送邮件，
因而你可以创建一台邮件服务器模拟谷歌、微软或腾讯等厂商向客户端发送邮件，
搭建邮件传输代理的工具有：sendmail、postfix、ssmtp（msmtp）等。
五 文件传输协议
（零）基本的ftp、scp这些就不说了，请去其操作文档看具体操作。
（一）NAS
0 NAS的概念：
（0）NAS是“网络附加存储”（Network Attached Storage）的缩写，指一种通过网络连接的存储设备，可以让多个用户和设备共享文件和数据。
（1）NAS所涉及到的协议就是文件共享协议（FSP），目前主流的FSP有：
a SMB/CIFS（Server Message Block/Common Internet File System）：
广泛用于Windows系统。
允许文件共享和打印服务。
CIFS是SMB 1.0。
虽然SMB被设计用于Windows，但是Linux用户可以通过Samba软件使用它。
默认端口445。
b NFS（Network File System）：主要用于Unix和Linux系统，支持远程文件系统的共享。
1 安全性：通过概念就可以看出该协议的存在虽然方便了办公但是存在严重的安全问题。
2 与SMB协议、NFS协议有关的命令请详见Windows命令、Linux命令。







第七章 网络安全（在本文档中不谈论翻墙（仅讨论VPN的基础IPsec协议和机场的基础TLS协议，在传输层一章中我们探讨了机场的概念基础：代理技术）、渗透测试、区块链（在传输层一章中探讨了区块链的一个技术点：P2P），这些安全技术我会专门开设文档）
一 基本概念
1 网络肯定是网络安全的基础，如果连网络的概念，协议的概念都没有，那么安全是根本搞不明白的。
2 计算机网络面临三类安全问题（注意：漏洞 == 脆弱点）：
（1）系统安全：入侵者通过互联网对联网计算机进行攻击（渗透测试或者DDoS攻击（smurf攻击和SYN flooding，在上文的ping和三次握手介绍过））。
运行时安全性：防御DDoS攻击。
软件安全（网络服务的安全）：白盒测试（代码审计）和黑盒测试（渗透测试，传统黑客，hack是个中性词，crack是贬义），黑+白=灰。
系统安全：防御非法入侵（防木马病毒），包括网络或主机这两类系统的安全，比如防火墙和入侵检测系统用来检测入侵流量，杀软用来检测木马等恶意软件以确保主机安全。
（2）通信安全：入侵者对经过互联网传输的数据进行攻击。
a 被动攻击：就是抓包，也叫监听、截获、嗅探（sniff）。在数据链路层一章中说过，以太网的网卡可以开启混杂（promiscuous）模式，可以监听网络上的所有数据，因而被动攻击是无法避免的，只能通过加密的方式让攻击者不知道数据内容。
b 主动攻击：对截获的数据进行丢弃、篡改（劫持，重放攻击，中间人攻击），或者模仿发送方发送伪造数据（RST断网攻击）。
通信安全三要素：
（a）机密性：对数据进行加密，截获虽然防不了但是让监听者看不懂数据内容也行。
（b）鉴别（认证，鉴权，总之就是authentication）：确保对端确实是在和自己想通信的对端通信。换言之，验证用户是否拥有访问系统或者某个资源的权利。
（c）完整性：防御重放攻击。
注：以上三种分别对应了密码学的三类核心技术，保障通信安全。
（3）人。
3 感悟：
（1）既然是安全，那就有对抗，即攻防，防御主要是网络安全设备在做，渗透测试即是进攻，因而渗透测试工程师也被认为是传统意义上的黑客（但是我认为只有从事逆向开发的工程师才是真正的黑客，他们真正精通计算机的底层逻辑）。
（2）密码学及所产生的安全协议是网络安全的根基，但是问题是密码学技术可以用于防守，也可以用于攻击：使用TLS协议加密应用层数据这是为了数据的机密性，防监听，但是黑客可以使用密码学技术开发VPN或者ss等代理以绕过GFW的检测实现翻墙上网，这是进攻；VPN和代理这个东西本身就是可攻可守。
二 密码学基础（1 计算上不可破，而不是理论上不可破 2 密码编码学和密码分析学组成密码学）
（一） 密码学基础（从这里开始要学习ssl库（sudo apt install libssl-dev）、openssl工具以及ssh等关于密码学的相关命令）
在通信安全上的作用：机密性保障。
1 对称加密：DES（这个已经不太行了）、3DES、AES（128、192、256位密钥，AES256是我们最常用的，密钥越长越安全但效率也越低）。
（1） 特点：算法公开、密钥保密。
（2） 加密过程：通信双方使用同一密钥进行加解密。
（3） 密钥（Secret Key）的生成：一般由密码（一个字符串，这是需要绝对保密的，不可在网络上传输）生成，且该过程不可逆。
（4） 加盐（解决一致性问题）：同一密钥、同一明文，生成的密文肯定是一致的，因而这里可能会被彩虹表攻击，可以加盐，加的盐如果短的话也不行（WEP协议的漏洞），会容易被破解。
2 非对称加密：RSA。
（1） 产生原因：一是对称密钥不好分配，比如要更换密钥，如何传输这个密钥，不能网络传，用信件又很慢，KDC虽然安全但是耗费网络资源，二是对数字签名的需要。
（2） 特点：算法公开、私钥保密、公钥公开。
（3） 加密算法：A向B发送数据，则A使用B的公钥加密数据（因而在连接初期（第一次或者第二次握手），B就给把自己的公钥发给A），发给B后B使用自己的私钥解密数据。
（4） 密钥的生成（区块链的核心基础）：字符串（区块链叫助记词，也就是密码，ssh-keygen的时候密码也能不写）->私钥->公钥->账号（区块链生成的是地址）。
（5） 公私钥与对称密钥的不同：
a 对称密钥加密也由它解密，但公钥和私钥可以加密明文，却不能解密。公钥加密了，只能由私钥解密，反之，私钥加密了，只能由公钥解密。
b 不同于对称密钥只能用于一对一通信，公私钥可以用于多对一通信。
（6）公钥算法的缺点：虽然看上去公私钥要比对称密钥更好，但是公私钥的开销较大，因而在机密性这个点上公私钥更多时候用于加密对称密钥，然后使用对称密钥进行通信。
（7）私钥一旦泄露意味着机密性丢失，因而一般认为私钥不可在网络上传输，就算cat也不要cat它。
（8）安全问题：如果公钥可信，那么之后，公钥加密是可以的，但是公钥是需要进行交换的，如果在交换中发生中间人攻击导致公钥本身就不可信呢？因而这也是证书的产生原因。
（二） 数字签名
在通信安全上的可提供实体鉴别（鉴别（很多时候也叫鉴权或验签）分为实体鉴别或端点鉴别和报文鉴别，实体鉴别只鉴别一次，报文鉴别包括实体鉴别和完整性）、完整性、不可否认性，但是事实上由于数字签名的开销较大，很多时候并不使用其做完整性，而是仅在通信伊始提供实体鉴别和不可否认性。
数字签名的逻辑是：
A向B发送数据，那么B怎么知道这是A在向我发包而不是什么黑客在向我发包呢？B又怎么知道A发的数据没有被黑客篡改呢？如果A后续否认了这个发包，B又怎么反击A呢？
1 实体鉴别：
a 验签的过程：A在发送数据时使用A的私钥进行加密，生成一个值作为数字签名，将签名和明文一起发送到B后，B使用A的公钥对密文解密（因而在握手初期B必须拿到A的公钥），发现原明文和通过公钥解密得到的明文一致则说明这确实是A发的。
b 原理：因为这个世界上只有A有A的私钥，只有A能生成用其公钥解密后能够和原明文比对成功的密文，如果有黑客C想伪造自己是A，他没有A的私钥，他只能用自己的私钥加密，此时B用A的公钥解密一个用C的私钥加密的密文，结果必然和原明文不一致。
c 安全问题：如果公钥可信，那么之后，数字签名可以保证鉴别的正确性，但是公钥是需要进行交换的，如果在交换中发生中间人攻击导致公钥本身就不可信呢？因而这也是证书的产生原因。
e 认证技术：
（a）对一般认证的认识：
从日常来看：注册 + 登录 + 注销 + 找回密码，这一整套都是认证技术。
认证的元素：账户 = 账号（用户名） + 密码
账号的特性：唯一性。多为手机号，有的系统会要求用户自定义用户名。
密码的特性：不可见性。密码的本质在于为了证明某个实体拥有访问某个实体的权限，所以这一点决定了密码的不可见性。
现在的应用场景：使用手机验证码作为密码登录的情况是最多见的。
安全问题：登录从最根本上说是一次TCP连接，而TCP连接无法被限制，这导致暴力破解具备可行性。
（b）数字签名是一种特殊的认证技术：
验签的原理就是私钥只可能被一个实体知晓，所以只要用这个实体的公钥解密成功那么就说明确实是这个实体。（这就是为什么JWT是不需要存储任何状态的）
ssh私钥登录就是经典例子，在ssh命令文章中有具体的操作步骤。
数字签名使得暴力破解不具备可行性。
但是由于客户端证书的不普及所以这种基于数字签名的登录还不是很普及，因而弱口令漏洞还是严重的安全威胁。
（c）用于维持登录状态的认证（会话管理）
ssh不需要，因为它就是一个资源即bash。
http需要，因为用户会访问很多资源，如果要对每个资源做认证那么用户要烦死了。
cookie和JWT应运而生了。
在HTTP部分我们详细介绍这两种技术，这里只说明关于认证的思路。
cookie的思路：用户携带着服务器分配给用户的仅有用户自己知道的信息到服务器，服务器会在数据库里面查有没有这个信息，有那就说明登录了，没有就让用户去用用户名和密码登录。
（d）使用数字签名的会话管理技术（JWT，思路很清奇）
JWT的思路：用户携带着服务器分配给用户的仅有用户自己知道的信息（这个信息是被服务器私钥签过名的）到服务器，服务器用自己的私钥解密，因为只有服务器自己能解密所以服务器就会认为这个客户端已经登录过了要不就是解密不可能成功。
2 完整性：B在使用A的公钥解密后得到与原明文一致的明文则说明报文未被篡改，因为如果黑客改了他没有A的私钥就生不成可以成功骗过B的密文；
3 不可否认性：如果将来A否认自己向B发过这个包，那么B可以把这个包（明文+密文）发给任何其他人，其他人都是知道A的公钥的，对密文解密发现与原明文一致，因而大家便会认定这是A发的。
（三） 完整性（数字指纹、数字摘要）
1 数字签名在保障完整性方面开销较大，因而产生了数字指纹或者说摘要这种简易方法。
2 数学家发明了一种函数，叫密码散列函数（哈希算法），其中散列，英文名hash（这便是哈希的由来）。辨析：哈希是一种算法（由一个值算成另一个值），哈希值是得到的值，哈希值也叫指纹、摘要（digest）。
3 密码散列函数有如下特点：
（1） 是单向函数即正着算容易算但反着算不可能；
（2） 可以得到固定长度的输出；
（3） 不同明文可能得到同一摘要，这又称为哈希碰撞，但是好的哈希算法是可以避免这种情况的，比如sha256。
4 目前主流的哈希算法有：
（1）MD5（Message Digest 5）：128位（16B），表示为32字节；
注：位数除以8是字节数，这是实际存储的字节数，但是我一般使用十六进制表示，因而MD5的十六进制表示32B。
（2）SHA（Secure Hash Algorithm）系列：
SHA-1: 160位，表示为40B
SHA-224: 224位
SHA-256: 256位，表示为64B
SHA-384: 384位
SHA-512: 512位
最广泛使用的哈希算法便是sha256，大名鼎鼎的比特币便使用该算法。
5 哈希算法如何确保报文完整性？
A向B发送报文，sha256（明文）得到哈希值作为报文鉴别码，放在明文中一起加密并传输，B收到后解密，再计算sha256（明文）则得到哈希值，和报文鉴别码比对，一致则完整没被篡改，不一致则被改了。
那么如果黑客截获，改掉了明文并使sha256（改掉的明文）得到一个新的哈希值作为报文鉴别码呢？事实上黑客是不可能在加密的数据中正好做到这一点的，因而完整性正是为了防止黑客“偷鸡不成蚀把米”，看不到数据就瞎改，他只要改，哈希值就对不上。
（四） 密钥分发中心（KDC）
0 KDC是一个密钥分发的问题，密钥管理是除了老三样的密码学核心问题之一。
（1）密钥管理包括密钥的产生、分配、注入、验证、使用。
（2）分配是最核心的问题。
（3）为什么需要密钥管理？这个问题涉及一个计算机的根本问题（是的，这是任何人学习计算机的第一课）：计算机上所有的软件或者说数据本质上都是二进制，数字本来就是，字符通过字符集和编码被转换为二进制（ASCII、UTF-8等），当然也有URL编码、base64编码等经典的转ASCII码的编码，注意，我们谈到了一个词叫编码，是的，一切东西都需要编码，编码的过程就是加密的过程，同理，解码即解密的过程，但是加解密要比编解码多了一个东西，那就是密钥，如果没有密钥，那么加解密就是编解码了。
（4）密钥管理的重要性：根本性重要。密钥被黑客截获意味着对黑客而言加解密将不再是加解密而是计算机技术本就使用的编解码。
（5）密钥能被截获吗？（换言之，密钥的传输安全能保证吗？）
首先密钥不可能不在网络上传输，除非军方网络可能会使用人工，因而兹要它在网络上传输那么就存在被截获的可能性。
其次公钥体制下，截获公钥没啥用，而私钥根本就不传输，因而公钥体制有效避免了密钥被截获的问题。
最后对称密钥是可能被截获的，这一点是内网横移的根本思想。
另外，有人说，要不再给密钥加密？可是终究要有明文密钥的存在。
（6）KDC的工作原理：
假设A要和B通信，前提是A和B都已经在KDC上注册过了即KDC保有了A和B的主密钥（master key，KA和KB）。
第一步：A向KDC发起请求说明希望和B通信。
第二步：KDC产生一个随机的会话密钥KAB，响应一个使用KA加密的[KAB，请A转给B的票据（ticket）]给A，其中，ticket是使用KB加密的[KAB]
第三步：A拿到[KAB，请A转给B的票据（ticket）]后，解密得到ticket，发送给B。
第四步：B拿到ticket后，解密拿到KAB，自此，A和B就可以愉快地通信了。
1 对称密钥的分配：kerberos协议
（1）用途：内网渗透中著名的域协议的核心协议之一（域协议准确的说是keberos和SMB、NFS等文件共享协议的结合，SMB负责文件共享（该协议将在），Kerberos负责认证）。
（2）为什么在内网中得到了广泛应用？对称密钥的分配很容易被截获，所以这个协议在公网根本活不下去，但是在内网由于其高效被广泛使用，当然这也为内网渗透提供了土壤。
（3）原理：
a 设备：一台AS（Authentication Server，掌握各个实体的身份和口令（用来生成各个实体的主密钥））和一台TGS（Ticket-Granting Server）。
b 前提：假设A要和B通信，前提是A和B都已经在AS和TGS上注册过了即AS和TGS保有了A和B的主密钥（master key，KA和KB）。
c 步骤：
第一步：A向AS发起身份认证请求，认证成功AS允许A和TGS通信。
第二步：AS向A发送用KA加密的[A和TGS通信的会话密钥KS，AS要发给TGS的ticket]，其中，ticket是使用KTG加密的。
第三步：A使用KA取出KA加密的[A和TGS通信的会话密钥KS，AS要发给TGS的ticket]，向TGS发送[AS要发给TGS的ticket]，当然还有其他的信息，比如为了预防重放的时间戳。
第四步：TGS向A发送使用KS加密的[KAB]，向B发送使用KB加密的[KAB]。
注：这里为什么不使用KA加密而使用KS，我也不知道，我觉得也能用KA。
第五步：A使用KAB加密一个时间戳发给B，B把时间戳加一并使用KAB加密发给A，接下来愉快通信。
2 公钥的分配（说的是公钥的分配，但是公钥不就是在连接初期就某一方给到某一方吗？（在HTTPS中就是第二次握手中网站把证书（包含公钥）给到了客户端）是的，所以公钥分配协议重在解决在分配过程中如何避免中间人攻击）：
（1）背景：比如你现在要登陆一个网站，你如何知道知道这是一个合法网站而不是一个钓鱼网站呢？
（2）根据背景可以看出（引出CA）：在验签之前，让不可信的通信双方交换公钥可能会产生中间人攻击，为了避免这一点，需要一个可信的具备权威性的中心组织（认证中心，CA）来管理公钥和实体间的对应关系，这样，当某一方需要与该实体进行通信时则可以去CA验证这个公钥的合法性，继而验证实体的合法性。
（3）申请CA证书的前置知识：一个网站如果采用HTTPS那么势必会用到证书，而且一个正规网站还得使用CA证书而非自签证书（不是说自签证书不能用而是你用了人家浏览器不认啊，很多浏览器都不认可自签证书），因而基于HTTPS的网站需要向CA申请一个证书（Cerficate，一般叫CA证书）以确保自己的网站能够支持HTTPS。
（4）如何使用openssl工具申请CA证书？（事实上有很多协议，但是我们这里着重介绍用于TLS的X509协议，这是被最广泛应用的公钥分配协议）
a 生成网站公私钥对：
（a）生成私钥：openssl genpkey -algorithm RSA -out private.key -aes256
（b）生成公钥：openssl rsa -in private.key -pubout -out public.key
注：
（a）aes256指使用aes256加密私钥文件，也能不用。
（b）这个私钥是256B（2048b）的，这是默认值。
b 生成CSR（Certificate Signing Request）：
openssl req -new -key private.key -out request.csr
注：
（a）证书签名请求为什么叫签名？因为CSR将被网站私钥签名，CA将使用网站公钥验证签名。
（b）CSR里包含公钥信息。
（c）如果你仅仅是想测试或者你的应用程序不需要公开证书（比如ssh），那么可以生成一个自签名证书：openssl req -x509 -key private.key -in request.csr -out certificate.crt -days 365，如果你使用了自签名证书，那么后面就不需要了。
c 在选中的证书颁发机构的网站上注册、填写相关信息、上传CSR，然后等待审核结果。
d 审核通过后在服务器上安装证书，就是放在某个路径下，这的看服务程序的指定。
（5）CA（Cerification Authority）：一般由政府和大公司组建，是可信的具备权威性的机构，CA的工作主要是：
a 接收并审查服务的CA证书申请请求（CSR），挑战响应协议； 
b 记录CA证书和服务的映射关系；
c 接收客户端对某服务器CA证书的验证请求并响应验证结果。
（6）现行的CA证书标准结构由X.509协议规定，因此在使用openssl和libssl库时，你会经常见到X509，请不要感到陌生。
（7）明确一些名词：证书是certificate而不是CA，CA是证书的认证机构，经常叫认证中心，经常把证书（certificate）叫CA证书，但是证书分为两种一种是CA证书，一种是自签名证书也叫本地证书。
a 自签证书在使用时需要把证书链给到客户端，其实对于客户端而言真正有价值的信息也就是公钥，因而使用自签证书的程序的验证说白了就是比对公钥（在ssh协议中这一点体现的很充分）。
b CA证书在使用时就不需要非得把证书链给到客户端，因为客户端没有证书链可以去CA进行验证。
（8）X509证书的主要信息有：
a 域名；
b 公钥；
c 颁发机构；
d 到期时间。
（9）如何在Windows下配置受信任的证书：Win + R，certmgr.msc。
（10）证书的后缀名一般写成.crt、.cer、.pem，这个很重要，有的软件他就认这个。
三 安全协议
（一） 网络层（IPsec）
1 IPsec协议族：IPsec并不是一个具体协议，而是一个协议规范。
2 IPsec协议族可划分为以下三部分：
（1）IP安全数据报格式的两个协议：Authentication Header和Encapsulation Security Payload，注：ESP协议包含在AH协议内；
（2）加密算法；
（3）互联网密钥交换IKE（Internet Key Exchange）协议。
3 使用了ESP协议的IP数据报叫IP安全数据报或者IPsec数据报。
4（重点） IPsec数据报有两种工作方式：
（1）传输方式：给传输层分组加首尾部，再加上IP头；
（2）隧道方式：给IP数据报加首位部，再加IP头。
注（重中之重）：
（1）不管那种方式，IP头都不被加密；IP头不可能被加密，因为路由器不支持；
（2）传输方式保护到传输层首部，隧道方式保护到网络层首部；
（3）应用层数据往往会被TLS或者一些加密算法比如AES或者RSA保护，所以IPsec着重保护的是TCP、UDP、IP的头，尤其是头中的端口号和IP地址信息。
5 安全关联的概念：主要对应格式中的安全参数索引SPI，IPsec软件必须维护每一个SA的状态信息：
（1）SPI；
（2）SA的源IP和目的IP地址；
（3）加密方式和加密密钥；
（4）完整性检查的方式，比如MD5或SHA系列；
（5）鉴别使用的密钥；
6 IPsec数据报格式：任何包就是首部和payload（我们一般叫IPsec的首部叫新首部）
拿隧道方式为例：
（1）新首部就是一个IP数据包的首部，但是要注意：
a 协议字段值为50，表明载荷是ESP包，这个事实际上让别人能够明确知道这是一个IPsec数据报而非普通的IP数据报；
b IPsec一般有两种应用场景，一个是网关对网关，源IP和目的IP是两个网关的源IP和目的IP，一个是网关对客户机，源IP则是网关和客户机的IP，这个客户机的IP很有可能会被NAT转换，但是这不影响什么，因为IPsec软件在客户机上。
（2）payload部分分为：鉴别区和报文鉴别码区，鉴别区又分为ESP首部和加密区，加密区又分为原IP数据报区和ESP尾部，尾部又分为填充区和一个8位的标识填充位数的字段和8位的标识下一个首部的字段（IP是4）：
a 为什么要有填充区？因为很多加密方式要求被加密数据长度是若干字节的整数倍，就比如AES加密算法对输入数据的长度要求是16字节（128位）的整数倍，无论是AES-128、AES-192还是AES-256；
b 下一个首部其实就相当于协议字段，都是“粘合剂”，只是叫法不同，IPv6就叫协议字段位下一个首部；
c ESP首部是不被加密的，其32位的SPI字段用来标识SA，32位的序号字段用来防止重放攻击；
d 报文鉴别码负责鉴别和完整性检查。
7 理解：通过对IP数据报格式的学习，可以看出，这个协议综合了加解密、鉴别、完整性、防重放安全机制，囊括了通信安全的所有机制，另外还涉及网关开发的知识，主要会用到原始套接字编程。
（二） 运输层（SSL/TLS）
1 TLS协议的前置知识是：密码学基础（机密性、数字签名、完整性、X509协议），尤其是X509涉及到的CA证书问题。
2 主要就是四路握手，但也涉及一些基础问题：
（1）基础问题：
a SSL和TLS就是一个东西，SSL是1994年Netscape开发的基于socket函数族的一套”密码学socket函数族“，TLS是1995年IETF接手SSL后确定的标准协议，因此该协议一般写作SSL/TLS，我一般叫TLS；
b（重要问题） TLS协议到底是哪一层的协议？传输层or应用层？注意按照五层模型，它是应用层；按照七层模型，它是会话层（我们熟悉的代理就是会话层）和表示层（负责数据格式的转换，比如编解码、加解密、压缩解压缩）。
下面着重解析四路握手：
第一次握手：client发送client hello包，包含可选密码列表、随机字符串C、SNI等信息，包含完整性，没有鉴别和机密性；
第二次握手：server发送server hello包，包含选定的密码组合、随机字符串S、CA证书等信息，包含完整性和鉴别，这个握手过去后，client能通过CA证书得知公钥，因而可以对数据报进行鉴别；
第三次握手：
先验证：client在发送该握手之前会去验证该证书的合法性（验签），这包括去自己的certmgr.msc（Windows环境）这里查看是否存储有该CA证书然后验签，或去CA那进行验签，client会对证书链的所有证书进行验签，
如果验证不通过，这里就要看浏览器的具体做法了，一般浏览器在未强制设置的情况下不会阻止用户继续访问，只是会提醒用户”该网站不安全“，用户还是可以选择”无视风险，继续访问“，事实上用户也可以配置不对证书进行验证，
如果验证通过了，那么浏览器不会进行任何其他的提示，
不管是验证通过了还是用户”无视风险继续访问“，都将发送第三次握手，
第三次握手主要包括一个用对端公钥加密的prematser secret，完整性、签名、公钥加密；
第四次握手：不管是client还是server此时都有相同的随机字符串C、S、premaster secret，它们用这些信息生成对称密钥以用来将来的对称加密，然后互发第四次握手finished，然后握手结束，数据通信开始。
3 TLS协议的后置知识是：SSL中间人攻击（bettercap），SSL strip攻击，这不是钓鱼（丢弃那个情况属于钓鱼）而是重放。
（三） 应用层
1 PGP
四 网络安全设备（系统安全）：分组过滤器（TCP/IP层）->网关（应用层）->DPI（应用数据层）
1 防火墙
（1）分组过滤器（netfilter（iptables））：根据运输层协议首部和网络层协议首部进行粗粒度过滤。
（2）网关（代理服务器）：深网一组的主要工作，主要是在Linux环境下使用C语言和网络编程技术去开发一些网关、网闸、光闸（单向网闸）等安全设备，针对于某一种应用比如FTP。
2 入侵检测系统
不光看首部也看应用层数据部分，这叫深度分组检查（DPI，GFW在做的事），其系统叫入侵检测系统（IDS），基于特征或者基于异常进行检测，深度学习的核心应用领域；
有一个DMZ（demilitarized zone）概念，指安全性较低的区域，比如公共web服务器所在的区域。
