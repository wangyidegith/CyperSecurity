一 基本问题
1 版本



二 开发环境（在哪执行）
a <script>标签里
b 事件属性里
c 浏览器后台console



二 语法：遵循ECMAScript，C系
注：只讲数据（运算和C语言一摸一样）：
（一）内存：
var：全局
let：局部
const：常量
（二）变量的声明（没有typedef，JS也会声明函数、结构、类）、定义、初始化：
a 定义：var let const ，也能像python那样隐式声明，默认为var，但是ECMAScript 5禁止这样做，且这样可读性很差。
b 初始化：let必须初始化，var默认值为undefined。
（三）总结var和let的区别：
a 作用域：var全局，let局部；
b 初始化：var默认指undefined，let必须初始化；
c 重复声明：var重复声明会覆盖，let不行；
d 暂时性死区：var可以在定义之前访问，let不行。
（四）数据类型：
1 基本数据类型：
（1）
console.log(typeof 42);        // "Number：整数和浮点，还有三个特殊的Infinity、-Infinity和NaN(Not a Number)"
a Infinity：
通过 Infinity 关键字或者 Number.POSITIVE_INFINITY 来获得。
任何正数除以 0 都会得到 Infinity。
Infinity 参与算术运算时,结果也会是 Infinity。
b -Infinity：
可以通过 -Infinity 或 Number.NEGATIVE_INFINITY 来获得。
任何负数除以 0 都会得到 -Infinity。
-Infinity 参与算术运算时,结果也会是 -Infinity。
c NaN（表示一个不合法或无法表示的数值）：
通常在数学运算中出现错误时会得到 NaN，比如 0/0、Infinity-Infinity 等。
NaN 不等于任何值，包括它自己。
使用 isNaN() 函数可以检查一个值是否为 NaN
任何涉及 NaN 的运算都会得到 NaN。
（2）
console.log(typeof "hello");    // "String：单双反皆可"
（3）
console.log(typeof true);       // "Boolean：true和false"
（4）
console.log(typeof null);       // "object" (这是一个已知的bug)
（5）
console.log(typeof undefined);  // "undefined：表示一个变量已被声明但未被赋值,或者根本就没有被声明"
（6）
console.log(typeof Symbol());   // "Symbol"
symbol和const的三点区别：
a 隐藏属性:
Symbol 主要用于为对象添加独一无二的属性键(property key),这些属性键是不可枚举的,可用于隐藏某些对象属性,避免与其他代码产生冲突。
b 全局性:
Symbol 值可以是全局的,也可以是局部的(使用 Symbol.for() 方法创建)。这样可以保证标识符的唯一性。
const 是块级作用域,只在声明它的代码块内有效。
c 描述性:
创建 Symbol 时可以给它一个描述性的字符串,但这只是一个可选的标识,不是 Symbol 值的一部分。
const 声明的常量没有这种描述性。
（7）
console.log(typeof 9007199254740991n); // "BigInt"
2 构造数据类型：
（1）函数：
a 函数的声明形式：
（a）标准方法（最标准的定义方式，一般作为自定义函数的定义方法）：
function 函数名(args) {}
（b）函数表达式法（用法最广泛，用于给某些对象写回调函数）：
var/let 函数名 = function(args) {};
（c）箭头法（在fetch中常用，也是fetch回调函数的标准定义法）：
var/let 函数名 = (args) => {};
（d）两类特殊的函数：
GeneratorFunction
AsyncFunction
（2）对象：
a 自定义对象
（a）标准定义法
class 
constructor 
this 
extends
new
（b）原始定义法（构造函数定义法）：
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} makes a sound.`);
};

function Dog(name, breed) {
  Animal.call(this, name); // 调用父类构造函数
  this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype); // 继承父类原型
Dog.prototype.constructor = Dog; // 修正构造函数指向

Dog.prototype.woof = function() {
  console.log(`${this.name} the ${this.breed} says woof!`);
};

let dog = new Dog("Buddy", "Labrador");
dog.speak(); // 输出: "Buddy makes a sound."
dog.woof(); // 输出: "Buddy the Labrador says woof!"
b 内置：
（a）数组
只有它有foreach方法。
（b）JSON对象。
两种定义方法：
第一种（声明常用）：
let person = {
  name: "John Doe",
  age: 30,
  email: "john.doe@example.com"
};
第二种（用于从字符串转）：
let jsonString = '{"name":"John Doe","age":30,"email":"john.doe@example.com"}';
let person = JSON.parse(jsonString); // 反过来是stringify



三 内置对象和函数
（一）基本数据类型对象（数据包装对象）：Number String BigInt Boolean Symbol
（二）函数对象：Function GeneratorFunction（yield关键字） AsyncFunction（await关键字）
（三）错误对象：
Error
AggregateError
EvalError
RangeError
ReferenceError
SyntaxError
TypeError
URIError
（四）数学
Math
（五）日期
Date
（六）正则
RegExp
（七）数据结构：Array Map Set JSON（起初为JavaScript专用，后面发展为通用）
（八）WebAssembly：web汇编
（九）console 对象不属于 BOM（浏览器对象模型），而是属于 JavaScript 的一部分，主要用于在浏览器环境或 Node.js 环境中进行调试和输出日志。



四 BOM（JS通过BOM操作浏览器，HTML、CSS也属于浏览器的一部分）
（一）根对象：window
（二）window 的子对象：
1 document：DOM，格外说。
2 location：
window.location.href：当前URL（也可以用search）
window.location.hostname：主机名
window.location.pathname：路径名
window.location.protocol：协议
window.location.href = 'https://www.example.com';：跳转
3 navigator：浏览器的相关信息，比如：
navigator.appName：浏览器名
navigator.appVersion：浏览器版本
navigator.cookieEnabled：cookie是否启用
navigator.platform：操作系统
navigator.plugins：安装在浏览器的插件数组
4 screen
5 history：
back()：加载 history 列表中的前一个 URL
forward()：加载 history 列表中的下一个 URL
go(参数)：加载 history 列表中的某个具体页面（参数：前进(正数)或后退(负数)几个历史记录）
length：返回当前窗口历史列表中的 URL 数量
6 frames



五 DOM（DOM是JS操作HTML的中间件，DOM和HTML相互对应都是树结构，document对象代表根节点即<html>元素）
（一）Document:
1 定位元素：
document.getElementById(id): 返回具有指定id的元素。
document.querySelector(selector): 返回文档中匹配指定CSS选择器的第一个元素。
document.querySelectorAll(selector): 返回文档中匹配指定CSS选择器的所有元素的静态 NodeList。
document.getElementsByTagName(tagName): 返回带有指定标签名的元素的集合。
2 创建元素：
document.createElement(tagName): 创建指定的HTML元素。
document.createTextNode(text): 创建新的文本节点。
document.createComment('This is a comment'): 创建一个注释节点的 Node 对象
document.createElementNS(namespaceURI, qualifiedName): 创建具有指定的命名空间URI和限定名称的元素。
（二）Element:
element.getAttribute(name): 返回指定属性名的属性值。
element.setAttribute(name, value): 设置或修改指定属性名的属性值。
element.tagName: 标签名。
element.textContent: 内容。
element.innerHTML: 开始和结束标签之间的 HTML（很多时候就是textContent）。
element.appendChild(node): 将指定节点作为最后一个子节点添加到元素中。
element.removeChild(node): 从元素中删除指定的子节点。
element.addEventListener(event, function, useCapture): 向元素添加事件侦听器。（事件监听器：一（element）带三（事件类型，回调函数（事件处理函数、监听函数），选项），事实上很多标签都提供了集成事件监听器的属性以简化写法，比如form标签的onsubmit属性，比如button的onclick属性）
1 选项：
（1）可选参数，一个配置对象，包含以下属性：
capture：布尔值，指定事件是在捕获阶段（true）还是冒泡阶段（false，默认）处理。常用于高级事件处理场景。
once：布尔值，指定事件是否只执行一次，执行后自动移除监听器。
passive：布尔值，指定监听器是否为被动的，用于改善滚动性能。
（2）选项的使用形式：
element.addEventListener('click', listener, {
    capture: true  // 在捕获阶段处理事件
});
（3）capture：
冒泡阶段：事件从目标元素开始向上传播到祖先元素。
捕获阶段：事件从最外层祖先元素向下传播到目标元素。
2 事件类型：
（1）鼠标事件：
click - 鼠标点击事件
dblclick - 鼠标双击事件
mousedown - 按下鼠标按键时触发的事件
mouseup - 松开鼠标按键时触发的事件
mousemove - 鼠标移动时触发的事件
mouseover - 鼠标移入元素时触发的事件
mouseout - 鼠标移出元素时触发的事件
mouseenter - 鼠标进入元素时触发的事件（不冒泡）
mouseleave - 鼠标离开元素时触发的事件（不冒泡）
（2）键盘事件：
keydown - 按下键盘按键时触发的事件
keyup - 松开键盘按键时触发的事件
keypress - 在按下并释放键盘按键后触发的事件（已不推荐使用）
（3）表单元素事件：
input - 输入框内容发生变化时触发的事件
change - 表单元素值改变时触发的事件（通常与 <input>、<select> 和 <textarea> 元素一起使用）
（4）焦点事件：
focus - 元素获得焦点时触发的事件
blur - 元素失去焦点时触发的事件
（5）页面加载和状态变化事件：
DOMContentLoaded - HTML 文档完成解析并完全加载完成时触发的事件
load - 整个页面（包括所有图像和样式表）加载完成时触发的事件
resize - 窗口或框架大小改变时触发的事件
scroll - 元素滚动时触发的事件
（6）其他常见事件：
submit - 提交表单时触发的事件
reset - 重置表单时触发的事件
error - 当加载文档或图像时发生错误时触发的事件
contextmenu - 右键点击元素时触发的事件
（7）触摸事件（移动端）：
touchstart - 触摸屏幕时触发的事件
touchmove - 在屏幕上滑动时触发的事件
touchend - 触摸结束时触发的事件
touchcancel - 触摸被取消时触发的事件
element.classList: 元素的类列表对象，可以用于添加、删除和切换类名。
{
add('className'): 添加指定的类名。如果元素之前没有这个类名，则将其添加到元素的类列表中。
remove('className'): 移除指定的类名。
toggle('className'): 如果元素之前有指定的类名，则移除它；如果没有，则添加它。
contains('className'): 检查元素是否包含指定的类名，返回布尔值。
}
3 示例：
<form id="myForm" action="/submit-form" method="POST">
    <label for="username">用户名：</label>
    <input type="text" id="username" name="username" required>

    <label for="password">密码：</label>
    <input type="password" id="password" name="password" required>

    <input type="submit" value="提交">
</form>

<script>
document.getElementById('myForm').addEventListener('submit', function(event) {
    event.preventDefault(); // 阻止表单默认提交行为

    // 执行你需要的操作，比如发送AJAX请求或者跳转页面
    // 这里可以添加你的代码逻辑

    // 例如，发送AJAX请求
    let formData = new FormData(document.getElementById('myForm'));
    fetch('/submit-form', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        // 在这里处理服务器响应后的逻辑
        console.log('提交成功');
        // 可以在这里进行页面重定向或其他操作
    })
    .catch(error => {
        console.error('提交失败', error);
    });
});
</script>
（三）Node:（它不是元素也不是标签、属性、内容，也不是注释、事件，而是所有这些节点的基类）
node.childNodes: 返回一个包含指定节点的子节点的 NodeList 对象。
node.parentNode: 返回指定节点的父节点。
node.nextSibling: 返回指定节点之后紧跟的节点。
node.previousSibling: 返回指定节点之前紧跟的节点。
node.textContent: 设置或返回节点及其后代的文本内容。
（四）Event:
event.preventDefault(): 取消事件的默认动作。
event.stopPropagation(): 停止事件在DOM中的传播。
event.target: 返回触发事件的目标节点。
event.currentTarget: 返回绑定事件处理程序的当前节点。
event.type: 返回事件类型的名称。
（五）Attribute:
attribute.name: 属性的名称。
attribute.value: 属性的值。
attribute.ownerElement: 属性所属的元素节点。
（六）Text:
textNode.data: 设置或返回节点的文本内容。
textNode.length: 返回节点文本内容的长度。
textNode.splitText(offset): 将文本节点从指定偏移量分割为两个文本节点。



六 HTTP
（一）form：这是最基本的send请求的方法
1 基本格式：
<form action="/submit-form" method="POST">
    <label for="username">用户名：</label>
    <input type="text" id="username" name="username" required>

    <label for="password">密码：</label>
    <input type="password" id="password" name="password" required>

    <input type="submit" value="提交">
</form>
2 三要素：
（1）action：请求要send到的URL。
（2）method：POST方法。
（3）{name, value}，这是表单提交数据的形式，后端的数据处理部分会对键值对进行操作。
3 这个方法比较原始没有像AJAX那样提供回调机制，因而在响应后你还没办法进行处理，所以表单提交的方法一般用于”只去不回“的场景（不回不是说没有响应而是这个响应不用APP处理，比如登录功能，响应了直接跳转），但是如果你非想使用form还要再APP层处理响应，那么只能通过onsubmit属性或者addEventListener的方法拦截submit，在回调函数里使用AJAX的方法send请求处理回调。
（二）AJAX（主要说fetch）
1 基本概念：
（1）所有的HTTP问题都是请求-响应问题，这是一个最基本的问题，而对于前端而言最基本的问题就是如何发送请求和接收响应。
（2）AJAX是在局部进行请求响应，事实上这是现在的主要形式，早期完整页面的请求响应是低效的。
（3）fetch是XMLHttpRequest（XHR）对象的现代版，但是fetch是函数。
2 语法：
（1）其基本形式为：fetch(url, json...).then(一个使用箭头法定义的匿名函数).then ...... .catch(error => {})，例如：
fetch('https://api.example.com/data', {method: 'POST', body: formData})
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error('Fetch error:', error);
  });
（2）其基本思路为：这是一种链式函数即一个函数的返回作为下一个函数的参数，这种既作为返回又作为参数的对象叫promise对象。
（3）fetch函数：
fetch是根函数（相当于form的submit，按照前端逻辑（比如点击一个按钮触发包含fetch的函数）发送请求，总之它没什么特殊的就是一个内置函数），参数是url、JSON（method、headers、body（JSON 字符串或 FormData 对象）、数据等（这个参数说白了就是一个form表单），返回值是response对象，返回的response对象作为下一个函数的参数，以此类推。
（4）FormData 对象：它不是一个标准的JSON，而是键值对集合。
第一个问题：如何创建一个FormData 对象
let formData = new FormData();
第二个问题：如何操作：
增：
append(name, value)：向 FormData 对象添加键值对。
删：
delete(name)：从 FormData 对象中删除指定键名的数据。
查：
get(name)：获取指定键名的第一个值。
getAll(name)：获取指定键名的所有值。
has(name)：检查 FormData 对象是否包含指定键名的值。
改：
set(name, value)：设置指定键名的值，如果已存在则更新。
（5）promise对象（根据JavaScript的语法，参数名是可以随便指定的，因而千万不要纠结名字，response也可以是resp什么的，这取决于用户的定义）
a 一般顺序：response -> data -> value，注：这个顺序不是确定无疑的而是取决于用户的使用，用户决定在某个then返回什么对象，那么下一个就是它。
b 状态：
"pending": Initial state, not fulfilled or rejected.
"fulfilled": The operation completed successfully.
"rejected": The operation failed.
3 注意：
（1）fetch 默认不会发送或接收任何 cookies，如果需要发送 cookies，需要设置 credentials 选项为 'include'。
（2）fetch 不会自动处理 HTTP 错误状态，例如 404 或 500。需要检查 response.ok 属性来判断请求是否成功。
（三）websocket和SSE（Server-Sent Events）
1 websocket
var socket = new WebSocket('ws://example.com/socket');
socket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    // 处理从服务器推送过来的数据
};
2 SSE
var eventSource = new EventSource('/events');
eventSource.onmessage = function(event) {
    var data = JSON.parse(event.data);
    // 处理从服务器推送过来的数据
};